# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")

pragma.enable("dot-props")
pragma.enable("accumulator")

def makeConvertENode2Term := <elang:visitors.makeConvertENode2Term>

def convert := makeConvertENode2Term()

def clQuote(s :String) {
  return "\"" + s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"") + "\""
}

def termToSExpression(term) {
  if (term =~ term`.String.@_`) {
    # Quote in accordance with Common Lisp reader syntax - no \letter escapes.
    return clQuote(term.getOptData())
  } else if (term =~ term`.int.@_`) {
    return term.asText()
  } else if (term =~ term`.char.@_`) {
    return "#\\" + E.toString(term.getOptData())
  } else if (term =~ term`.float64.@_`) {
    # Print as double-float
    def floatString := term.asText()
    if (floatString.indexOf("e") != -1) {
      return floatString.replaceAll("e", "d")
    } else {
      return floatString + "d0"
    }
  } else {
    return "(|" + term::tag::tagName + "|" + accum "" for x in term::args { _ + " " + termToSExpression(x) } + ")"
  }
}

def parseEToSExpression(verb, args) {
  return try { 
    switch (verb) {
      match =="run" {
        def [source] := args
        termToSExpression(convert(e__quasiParser(source)))
      }
      match =="isIdentifier" {
        def [word] := args
        if (<elang:syntax.ELexer>.isIdentifier(word)) {
          "cl:t "
        } else {
          "cl:nil "
        }
      }
    }
  } catch p { 
    `(ERROR ${clQuote(E.toQuote(p))})`
  }
}
