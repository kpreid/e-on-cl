# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")

pragma.enable("dot-props")
pragma.enable("accumulator")

def makeConvertENode2Term := <elang:visitors.makeConvertENode2Term>

def convert := makeConvertENode2Term()

def clQuote(s :String) {
  return "\"" + s.replaceAll("\\", "\\\\").replaceAll("\"", "\\\"") + "\""
}

def termToSExpression(term) {
  if (term =~ term`.String.@_`) {
    # Quote in accordance with Common Lisp reader syntax - no \letter escapes.
    return clQuote(term.getOptData())
  } else if (term =~ term`.int.@_`) {
    return term.asText()
  } else if (term =~ term`.char.@_`) {
    return "#\\" + E.toString(term.getOptData())
  } else if (term =~ term`.float64.@_`) {
    # Print as double-float
    def floatString := term.asText()
    if (floatString.startOf("e") != -1) {
      return floatString.replaceAll("e", "d")
    } else {
      return floatString + "d0"
    }
  } else {
    return "(|" + term::tag::tagName + "|" + accum "" for x in term::args { _ + " " + termToSExpression(x) } + ")"
  }
}

# --- ---

def author(<unsafe>) {




  #def <eantlr> := <unsafe:org.erights.e.elang.syntax.antlr.*>
  def <eantlr> := <unsafe>
  def <antlr> := <unsafe:antlr.*>
  def makeEParser := <eantlr:makeEParser>
  def makeEALexer := <eantlr:makeEALexer>
  def makeQuasiLexer := <eantlr:makeQuasiLexer>
  def makeTokenMultiBuffer := <antlr:makeTokenMultiBuffer>
  def makeTokenStreamSelector := <antlr:makeTokenStreamSelector>
  def makeDumpASTVisitor := <antlr:makeDumpASTVisitor>
  
  def tokenSymbols := accum [] for tn in makeEParser.get_tokenNames() { _.with("e.grammar::|" + tn.replaceAll("\\", "\\\\").replaceAll("|", "\\|") + "|") }
  
  def antlrParse(fname, text) {
    def elexer := makeEALexer(<import:java.io.StringReader>(text))
    def qlexer := makeQuasiLexer(elexer.getInputState())
    def tb := makeTokenMultiBuffer(["e", "quasi"], [elexer, qlexer])
    elexer.setSelector(tb)
    qlexer.setSelector(tb)
    elexer.setFilename(fname)
    qlexer.setFilename(fname)
  
    def parser := makeEParser(tb)
    parser.setFilename(fname)
    
    parser.start()
    def ast := parser.getAST()
    
    def [out, sb] := <elib:oldeio.makeTextWriter>.makeBufferingPair()
    
    def parentheses(body) {
      out.print("(")
      body()
      out.print(")")
    }
    
    def printChain(var ast) {
      while (ast != null) {
        out.print(" ")
        parentheses(thunk{
          parentheses(thunk{
            out.print(tokenSymbols[ast.getType()], " ")
            out.quote(ast.getText())
          })
          printChain(ast.getFirstChild())
        })
        ast := ast.getNextSibling()
      }
    }
    
    out.print("(")
    printChain(ast)
    out.print(")")
    return sb.snapshot()
  }




  def parseEToSExpression(verb, args) {
    return try { 
      switch (verb) {
        match =="antlrParse" {
          def [source] := args
          antlrParse("unknown", source)
        }
        match =="run" {
          def [source] := args
          termToSExpression(convert(e__quasiParser(source)))
        }
        match =="isIdentifier" {
          def [word] := args
          if (<elang:syntax.ELexer>.isIdentifier(word)) {
            "cl:t "
          } else {
            "cl:nil "
          }
        }
      }
    } catch p { 
      `(ERROR ${clQuote(E.toQuote(p))})`
    }
  }
  return parseEToSExpression
}