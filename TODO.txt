Major bugs:

  - An <import>.optUnget test gets null unexpectedly under CLISP and OpenMCL
    - try writing independent tests for path-loader to see if the problem is there
  - The standard rune-in-E code doesn't work (at last try it runs the script then goes off into an infinite loop with something counting up)

Minor bugs:
  
  - the sb-sprof profiling option in updoc.lisp doesn't work. The SBCL release after 0.9.1 might improve this.
  - clrune <relative-path-to-script> doesn't work because file__uriGetter doesn't accept relative paths. This is a design issue.

Internal bugs:

  - updoc can't be safely exposed to E since it's a top loop, which means we can't meta-test it

Little features:
  - serialization-base primitives: __optUncall where needed, selfless where needed, Loader#optUncall.
  - socket IO
  - more complete file IO
  - have updoc stop running a given script when a mismatch has occurred and a later step depends on a binding made/shadowed by that step
  - updoc should take options: profiling options, --confine

Big features:
  - term trees
  - true vats
  - boot-comm system
  - threaded vats
  - Audited Selfless for E-objects
  - Pluribus

Code cleanups not marked in the code:
  - reorganize: rename elang-transform.lisp to compiler-transform?
  - reorganize: rename elib.lisp once it's been pared down to just the external macros and stuff
  - reorganize: move stuff that isn't really about the root scopes out of knot.lisp
  - reorganize: rename tables2.lisp once elib-tables.lisp is gone

---

Notes on capturing stack trace:
  SBCL offers sb-debug:backtrace-as-list. CMUCL does not have this.
  
  <kpreid> Are there any semi-portable interfaces to capture a stack trace, as a debugger might do interactively?
  <tbmoore> kpreid: The swank support, perhaps.
  
  <Xach> swank doesn't use backtrace-as-list in the sbcl backend, but it does in the abcl backend
  <piso> yes, abcl also provides backtrace-as-list
  abcl: ext:backtrace-as-list
  
For encoding/decoding:
  sb-ext:octets-to-string byte-vector &key :external-format :start :end
  sb-ext:string-to-octets string &key :external-format :start :end :null-terminate
  
  for an incomplete utf8 sequence, octets-to-string will signal SB-IMPL::END-OF-INPUT-IN-CHARACTER, whose nearest external superclass is SB-INT:CHARACTER-DECODING-ERROR.
    * (sb-mop:class-precedence-list (find-class 'SB-IMPL::END-OF-INPUT-IN-CHARACTER))

---

E-in-S-expression syntax ideas (not necessarily to be implemented any time soon)

(def l (list l))

(do
  (def (list l__1 lR__3) (Ref :promise))
  (def res__5 (def l (__makeList :run l__1)))
  (lR__3 :resolve l)
  res__5)

(do
  (def simplifyFQName #<import:org.cubik.cle.prim.simplifyFQName>)
  
  (def makeAdvisoryInterface obj :implements DeepFrozen
    (to (:run typeDesc) (as any)
      (def advisoryInterface obj
          :extends (__makeGuard advisoryInterface)
        (to (:audit objectExpr witness) (as any)
          false)
        (to (:coerce specimen _) (as any)
          specimen)
        (to (:__printOn (as TextWriter out)) (as void)
          (out :print (simplifyFQName (typeDesc :getFQName))))))))
          


---

Arbitrary anonymous functions as type specifiers:

(lambda (guard)
  (let ((sym (make-symbol (e-quote guard))))
    (setf (symbol-function sym) 
      (lambda (specimen)
        (eeq-is-same-yet (e. guard |coerce| specimen)
                         specimen)))
    `(satisfies ,sym)))
  
  
---

This unfinished scrap of code from vtable-case-entry wouldn't have worked, but might have some use later

(let* ((name (format nil "~A#~A" type-name mverb))
               (sym 
                 ; These are feature conditionals to remind me that they must be set at compile time anyway.
                 #-e.intern-vtable-methods
                   (make-symbol name)
                 #+e.intern-vtable-methods
                   (loop 
                     for i from 1
                     for free = name then (format nil "~A-dup-~A" name i)
                     while (find-symbol name :e.elib.vtable-methods) 
                     finally (return (intern free :e.elib.vtable-methods)))))
          `(apply 
            #-e.intern-vtable-methods (named-lambda ,sym ,@(cdr desc))
            #+e.intern-vtable-methods
              ,(progn
                (...))
            ,@prefix-args
            ,args-sym))
            
---

Possibly for use in float next/previous methods

------ Begin Forwarded Message -------

Subject:     Re: A function returning the next representable floating 
             point value of an argument
From:        Bruno Haible <bruno@clisp.org>
Newsgroups:  comp.lang.lisp
Date:        24 May 2005 19:39:44 GMT

Christophe Rhodes wrote:
>>     (t (multiple-value-bind (significand exponent integer-sign)
>>            (integer-decode-float f)
>>          (let ((result (float (* (1+ significand)
>>                                  (expt (float-radix f) exponent))
>>                               f)))
>
> Hmm.  Without thinking /too/ hard about this, I'd venture that this
> isn't going to work in an implementation which represents its floating
> point values as IEEE single-floats, for F at the boundary between one
> exponent and the next, in round-to-even rounding mode.
> ...
> This would seem to be generating the next float further away from
> zero, not the next greatest float, for negative f.

You are right. But this one should work, uniformly producing the next
greater single-float, considering -0.0 and +0.0 as equal and ignoring
the problem of "denormalized floats":

(defun single-float-above (f)
  "Return the next representable single-float value greater than F."
  (check-type f single-float)
  (cond
    ((zerop f) least-positive-single-float)
    ((= most-positive-single-float f)
     (error "~f is most-positive-single-float." f))
    (t (multiple-value-bind (significand exponent integer-sign)
           (integer-decode-float f)
         (if (minusp integer-sign)
           (progn
             (when (zerop (logand significand (- significand 1)))
               (setq significand (* (float-radix f) significand))
               (setq exponent (- exponent 1)))
             (float (* (1+ (- significand)) (expt (float-radix f) exponent))
f))
           (float (* (1+ significand) (expt (float-radix f) exponent)) f))))))

The 'logand' part probably needs to be changed if (float-radix f) is not 2.
However, I don't know how the significand (mantissa) is normalized in
implementations where (float-radix f) is 4 or 16 or something like this.

P.S.: What do you need this for? You can implement TYPEP and SUBTYPEP
without needing this kind of operation on floating-point numbers.

                      Bruno

-------- End Forwarded Message --------
