# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

XXX todo: move everything else that should be here here

This file contains tests for the E parser's grammar; specifically excluding expansion, parser protocol, etc. '

  ? def makeVisitor(writer, depth) :any {
  >   return def condensedDumpVisitor {
  >     match [`visit@name`, [_] + elements] {
  >       def single := elements.size() <=> 1
  >       def step := if (single) { "" } else { "  " }
  >       writer.print(name.replaceAll("Expr", "E.").replaceAll("Pattern", "P."))
  >       def nextWriter := writer.indent(step)
  >       for element in elements {
  >         if (single) { nextWriter.write(" ") } else { nextWriter.println() }
  >         if (element.__respondsTo("welcome", 1)) { element.welcome(makeVisitor(nextWriter, depth + 1)) 
  >         } else if (element =~ l :List ? (l !~ s :String)) { E.call(makeVisitor(nextWriter, depth + 1), "visit[]", [null] + l) 
  >         } else {
  >           nextWriter.print(element)
  >         }
  >       }
  >     }
  >   }
  > }; null

? def pp := <import:org.cubik.cle.prim.parser>; null
? def rootVisitor := makeVisitor(stdout, 0); null
? def t(s) :any { return pp.run(s).welcome(rootVisitor) }; null

--- Sequence separators ---

No SeqExprs around single terminated exprs
  ? t("a;")
  # stdout: NounE. a
  ? t("{a;}")
  # stdout: HideE. NounE. a
  
Multiple separators of all types are allowed.
  ? t("a;;")
  # stdout: NounE. a
  ? t("a\n;")
  # stdout: NounE. a
  ? t("a;\n")
  # stdout: NounE. a
  ? t("a\n\n")
  # stdout: NounE. a

  ? t("{a;;}")
  # stdout: HideE. NounE. a
  ? t("{a\n;}")
  # stdout: HideE. NounE. a
  ? t("{a;\n}")
  # stdout: HideE. NounE. a
  ? t("{a\n\n}")
  # stdout: HideE. NounE. a

  ? t("{a\n\nb;;c;\n}")
  # stdout: HideE. SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c
  ? t("a\n\nb;;c;\n")
  # stdout: SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c

--- Acceptance of sequences everywhere they should be ---

NOTE: these tests were produced by inspection of antlr/e.g. They are not complete.

? t("__makeList(1;2)")
# stdout: FunCallE.
#           NounE. __makeList
#           [] SeqE. []
#             LiteralE. 1
#             LiteralE. 2

xxx Should we change the grammar so that pragmas don't create SeqExprs? '
? t("pragma.enable(\"trinary-define\"); def a := (1;2,3;4)")
# stdout: SeqE. [] DefrecE.
#           FinalP.
#             NounE. a
#             null
#           SeqE. []
#             LiteralE. 1
#             LiteralE. 2
#           SeqE. []
#             LiteralE. 3
#             LiteralE. 4

XXX ListExpr doesn't really belong here '
? t("[1;2 => 3]")
# stdout: MapE. [] ListE. []
#           SeqE. []
#             LiteralE. 1
#             LiteralE. 2
#           LiteralE. 3

? t("`${1;2}`")
# stdout: QuasiE.
#           null
#           [] QuasiE.Hole SeqE. []
#             LiteralE. 1
#             LiteralE. 2

--- Object expressions in high-precedence positions ---

Fails for the sake of sane precedence rules, even though it would be unambiguous, sort of.
? t("1 + def a := 2")
# problem: (unknown:1)@11: unexpected token: [":=",<155>,line=1,col=11]
XXX produce a nice error for this?

? t("a & def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] NKObjectE.
#             
#             IgnoreP.
#             null
#             []
#             EScript
#               []
#               []

? t("a & /**b*/def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] NKObjectE.
#             b
#             IgnoreP.
#             null
#             []
#             EScript
#               []
#               []

? t("a & thunk {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ThunkE.
#             
#             NullE.

--- Miscellaneous ---

? t("a :b[c]")
# stdout: CoerceE.
#           NounE. a
#           GetE.
#             NounE. b
#             [] NounE. c


XXX test acceptance of line breaks everywhere
XXX general parser tests for everything
