# Copyright 2005-2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

XXX todo: move everything else that should be here here

This file contains tests for the E parser's grammar; specifically excluding expansion, parser protocol, etc. '

? def pp := <import:org.cubik.cle.prim.parser>; null
? def dumpENodes := <import:org.cubik.cle.dumpENodes>; null
? def t(s) :any { return dumpENodes(pp.run(s), stdout) }; null
? def tp(s) :any { return dumpENodes(pp.pattern(s, null, null), stdout) }; null

--- Basic source positions ---

? pp.run("ab".asFrom("file:///foo")).getOptSpan()
# value: <file:///foo#:span::1:0::1:0>
should be 1:0::1:1 but we don't have span information yet

--- String syntax ---

? t("'\\u0021'")
# stdout: LiteralE. !

? t("\"\\u0021\"")
# stdout: LiteralE. !

? t("\"\\u00210000\"")
# stdout: LiteralE. !0000

? t("\"\\U00000021\"")
# stdout: LiteralE. !

? t("`$\\u0021`")
# stdout: QuasiE.
#           null
#           [] QuasiText !

? t("`$\\u00210000`")
# stdout: QuasiE.
#           null
#           [] QuasiText !0000

? t("`$\\U00000021`")
# stdout: QuasiE.
#           null
#           [] QuasiText !

--- Number commas ---

This behavior copied from E-on-Java.

? t("1_234")
# stdout: LiteralE. 1234

? t("12_34")
# stdout: LiteralE. 1234

? t("1_2_3_4")
# stdout: LiteralE. 1234

? t("1234_")
# problem: <TokenStreamRecognitionException: unexpected char: 0xFFFF>
    XXX improve this error message

? t("12__34")
# problem: <TokenStreamRecognitionException: unexpected char: '_'>

? t("_1234")
# stdout: NounE. _1234

--- Float syntax ---

A float may be marked by decimal places,

? t("3.2")
# stdout: LiteralE. 3.2

an exponent with optional sign,

? t("3e2")
# stdout: LiteralE. 300.0
? t("3E2")
# stdout: LiteralE. 300.0
? t("3e+2")
# stdout: LiteralE. 300.0
? t("3e-2")
# stdout: LiteralE. 0.03

or both.

? t("3.2e+2")
# stdout: LiteralE. 320.0
? t("3.2e-2")
# stdout: LiteralE. 0.032

A decimal point must have at least one following digit, because otherwise it is ambiguous with call syntax.

? t("3.")
# problem: (line 1)@3: unexpected token: ["null",<1>,line=1,col=3]
? t("3.e2")
# stdout: CurryE. CallE.
#           LiteralE. 3
#           e2
#           []

An additional dot always indicates call syntax.

? t("3.2.a")
# stdout: CurryE. CallE.
#           LiteralE. 3.2
#           a
#           []
? t("3e2.a")
# stdout: CurryE. CallE.
#           LiteralE. 300.0
#           a
#           []

There must also be at least one preceding digit.

? t(".2")
# problem: (line 1)@1: unexpected token: [".",<133>,line=1,col=1]

--- Nouns ---

? t("a")
# stdout: NounE. a

? t("pragma.enable(\"noun-string\"); a")
# stdout: SeqE. [] NounE. a

? t("pragma.enable(\"noun-string\"); ::\"a\"")
# stdout: SeqE. [] NounE. a

--- Function syntax ---

? t("pragma.enable(\"anon-lambda\"); fn { a }")
# stdout: SeqE. [] FunctionE.
#           []
#           NounE. a

? t("pragma.enable(\"anon-lambda\"); fn a { b }")
# stdout: SeqE. [] FunctionE.
#           [] FinalP.
#             NounE. a
#             null
#           NounE. b

? t("pragma.enable(\"anon-lambda\"); fn a, b { c }")
# stdout: SeqE. [] FunctionE.
#           []
#             FinalP.
#               NounE. a
#               null
#             FinalP.
#               NounE. b
#               null
#           NounE. c

? t("pragma.enable(\"anon-lambda\"); fn a, b, { c }")
# stdout: SeqE. [] FunctionE.
#           []
#             FinalP.
#               NounE. a
#               null
#             FinalP.
#               NounE. b
#               null
#           NounE. c

--- Sequence separators ---

No SeqExprs around single terminated exprs
  ? t("a;")
  # stdout: NounE. a
  ? t("{a;}")
  # stdout: HideE. NounE. a
  
Multiple separators of all types are allowed.
  ? t("a;;")
  # stdout: NounE. a
  ? t("a\n;")
  # stdout: NounE. a
  ? t("a;\n")
  # stdout: NounE. a
  ? t("a\n\n")
  # stdout: NounE. a

  ? t("{a;;}")
  # stdout: HideE. NounE. a
  ? t("{a\n;}")
  # stdout: HideE. NounE. a
  ? t("{a;\n}")
  # stdout: HideE. NounE. a
  ? t("{a\n\n}")
  # stdout: HideE. NounE. a

  ? t("{a\n\nb;;c;\n}")
  # stdout: HideE. SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c
  ? t("a\n\nb;;c;\n")
  # stdout: SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c

--- Acceptance of sequences everywhere they should be ---

NOTE: these tests were produced by inspection of antlr/e.g. They are not complete.

? t("__makeList(1;2)")
# stdout: FunCallE.
#           NounE. __makeList
#           [] SeqE. []
#             LiteralE. 1
#             LiteralE. 2

XXX ListExpr doesn't really belong here '
? t("[1;2 => 3]")
# stdout: MapE. [] ListE. []
#           SeqE. []
#             LiteralE. 1
#             LiteralE. 2
#           LiteralE. 3

? t("`${1;2}`")
# stdout: QuasiE.
#           null
#           [] QuasiE.Hole SeqE. []
#             LiteralE. 1
#             LiteralE. 2

--- Object expressions in high-precedence positions ---

Fails for the sake of sane precedence rules, even though it would be unambiguous, sort of.
? t("1 + def a := 2")
# problem: (line 1)@11: unexpected token: [":=",<162>,line=1,col=11]
XXX produce a nice error for this?

? t("a & def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ObjectHeadE.
#             
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []

? t("a & /**b*/def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ObjectHeadE.
#             b
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []

? t("a & fn {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] FunctionE.
#             []
#             NullE.

--- Result guards / easy-return ---

? t("pragma.disable(\"easy-return\")
>    pragma.enable(\"explicit-result-guard\")
>    def a() {}")
# problem: (line 3)@10: You must specify a result guard or disable "explicit-result-guard".
XXX source position

? t("pragma.disable(\"easy-return\")
>    pragma.enable(\"explicit-result-guard\")
>    def a{ to b() {} }")
# problem: (line 3)@16: You must specify a result guard or disable "explicit-result-guard".
XXX source position

? t("pragma.disable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def a() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             false

? t("pragma.disable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def a{ to b() {} }")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           MethodObject
#             null
#             []
#             [] ETo
#               
#               b
#               []
#               null
#               NullE.
#               false
#             []

? t("pragma.enable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def a() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             true

? t("pragma.enable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def a{ to b() {} }")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           MethodObject
#             null
#             []
#             [] ETo
#               
#               b
#               []
#               null
#               NullE.
#               true
#             []

--- pragma.syntax ---

? t("pragma.aardvarks()")
# problem: (line 1)@18: Unknown pragma "aardvarks".

? t("pragma.syntax(\"fnorg\")")
# problem: (line 1)@22: Unknown syntax version "fnorg".

0.8 has explicit-result-guard on and easy-return off.

? t("pragma.syntax(\"0.8\")
>    def a() {}")
# problem: (line 2)@10: You must specify a result guard or disable "explicit-result-guard".

? t("pragma.syntax(\"0.8\")
>    def a() :void {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             NounE. void
#             []
#             NullE.
#             false

0.9 has explicit-result-guard off and easy-return on.

? t("pragma.syntax(\"0.9\")
>    def a() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             true

Bug test: parsing only a pragma would fail.

? t("pragma.enable(\"accumulator\")")
# stdout: NullE.

XXX test resulting pragma state directly?

--- Function expressions ---

? t("def a() :b {}")
# stdout: ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             NounE. b
#             []
#             NullE.
#             true

? t("def a() :b implements c {}")
# problem: (line 1)@23: The optional "function-implements" syntax is currently off.

? t("pragma.enable(\"function-implements\"); def a() :b implements c {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             NounE. b
#             [] NounE. c
#             NullE.
#             true

Testing discrimination between functions and call patterns:

? t("pragma.disable(\"explicit-result-guard\"); def a() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             true

? t("pragma.disable(\"explicit-result-guard\"); pragma.enable(\"function-implements\"); def a() implements b {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             null
#             [] NounE. b
#             NullE.
#             true

? t("def a() :b {}")
# stdout: ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           FunctionObject
#             []
#             NounE. b
#             []
#             NullE.
#             true

--- modPow ---

? t("a ** b %% c")
# stdout: ModPowE.
#           NounE. a
#           NounE. b
#           NounE. c

Parentheses disable modPow form
? t("(a ** b) %% c")
# stdout: BinaryE.
#           %%
#           BinaryE.
#             **
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("a %% b ** c")
# stdout: BinaryE.
#           %%
#           NounE. a
#           [] BinaryE.
#             **
#             NounE. b
#             [] NounE. c

? t("a ** b % c")
# stdout: BinaryE.
#           %
#           BinaryE.
#             **
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("(a %% b) ** c")
# stdout: BinaryE.
#           **
#           BinaryE.
#             %%
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("a %% (b ** c)")
# stdout: BinaryE.
#           %%
#           NounE. a
#           [] BinaryE.
#             **
#             NounE. b
#             [] NounE. c

--- CoerceExpr ---

? t("{a} :b")
# stdout: CoerceE.
#           HideE. NounE. a
#           NounE. b

? t("def _ {} :a")
# stdout: CoerceE.
#           ObjectHeadE.
#             
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []
#           NounE. a

? t("a :b :c")
# problem: (line 1)@6: unexpected token: [":",<172>,line=1,col=6]
XXX prettier error

--- ForExpr ---

? t("for a => b in c { d }")
# stdout: ForE.
#           FinalP.
#             NounE. a
#             null
#           FinalP.
#             NounE. b
#             null
#           NounE. c
#           NounE. d
? t("for b in c { d }")
# stdout: ForE.
#           null
#           FinalP.
#             NounE. b
#             null
#           NounE. c
#           NounE. d

--- InterfaceExpr ---

XXX more tests (this section was written to test guardless ParamDesc)

? t("interface a { to b(c, d :e, _ :f, _) }")
# stdout: InterfaceE.
#           
#           FinalP.
#             NounE. a
#             null
#           null
#           []
#           []
#           [] MessageDescE.
#             
#             b
#             []
#               ParamDescE.
#                 c
#                 null
#               ParamDescE.
#                 d
#                 NounE. e
#               ParamDescE.
#                 null
#                 NounE. f
#               ParamDescE.
#                 null
#                 null
#             null

--- ObjectExpr ---

one-method-object
? t("def a.b() :c {}")
# problem: (line 1)@6: The optional "one-method-object" syntax is currently off.

? t("pragma.enable(\"one-method-object\"); def a.b() :c {d}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           FinalP.
#             NounE. a
#             null
#           OneMethodObject
#             b
#             []
#             NounE. c
#             []
#             NounE. d
#             true

--- URISchemeExpr ---

? t("<>")
# problem: (line 1)@1: unexpected token: ["<",<201>,line=1,col=1]

? t("<a>")
# stdout: URISchemeE. a

case processing
? t("<A>")
# stdout: URISchemeE. A

would-be-keywords
? t("<to>")
# stdout: URISchemeE. to

erroneous
? t("<ab cd>")
# problem: (line 1)@1: unexpected token: ["<",<201>,line=1,col=1]
? t("<+a>")
# problem: (line 1)@1: unexpected token: ["<",<201>,line=1,col=1]
? t("<a!b>")
# problem: (line 1)@1: unexpected token: ["<",<201>,line=1,col=1]

--- WhenExpr ---

? t("pragma.syntax(\"0.9\"); when (a) -> { b }")
# stdout: SeqE. [] WhenE.
#           [] NounE. a
#           WhenBlockE.
#             NounE. b
#             []
#             null

? t("pragma.syntax(\"0.9\"); when (a) -> { b } catch c { d } finally { e }")
# stdout: SeqE. [] WhenE.
#           [] NounE. a
#           WhenBlockE.
#             NounE. b
#             [] EMatcher
#               FinalP.
#                 NounE. c
#                 null
#               NounE. d
#             NounE. e

XXX incomplete tests; borrow when-fn examples from syntax-sugar

--- CallPattern, FunCallPattern, GetPattern ---

? tp("a.b(c)")
# problem: (line 1)@6: The optional "call-pattern" syntax is currently off.
? tp("a(b)")
# problem: (line 1)@4: The optional "call-pattern" syntax is currently off.

? t("pragma.enable(\"call-pattern\"); 0 =~ a.b(c)")
# stdout: SeqE. [] MatchBindE.
#           LiteralE. 0
#           CallP.
#             NounE. a
#             b
#             [] FinalP.
#               NounE. c
#               null

? t("pragma.enable(\"call-pattern\"); 0 =~ a(b)")
# stdout: SeqE. [] MatchBindE.
#           LiteralE. 0
#           FunCallP.
#             NounE. a
#             [] FinalP.
#               NounE. b
#               null

? t("pragma.enable(\"call-pattern\"); 0 =~ a[b]")
# stdout: SeqE. [] MatchBindE.
#           LiteralE. 0
#           GetP.
#             NounE. a
#             [] FinalP.
#               NounE. b
#               null

--- IgnorePattern / GuardTestPattern ---

? tp("_")
# stdout: IgnoreP.

? tp("_ :int")
# stdout: GuardTestP. NounE. int

--- Via-pattern ---

? tp("via (a) b")
# stdout: ViaP.
#           NounE. a
#           FinalP.
#             NounE. b
#             null

--- Miscellaneous ---

? t("a :b[c]")
# stdout: CoerceE.
#           NounE. a
#           GetE.
#             NounE. b
#             [] NounE. c


XXX test acceptance of line breaks everywhere
XXX general parser tests for everything

x ? t("")
x # stdout: 
