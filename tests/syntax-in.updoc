# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

XXX todo: move everything else that should be here here

This file contains tests for the E parser's grammar; specifically excluding expansion, parser protocol, etc. '

? def pp := <import:org.cubik.cle.prim.parser>; null
? def dumpENodes := <import:org.cubik.cle.dumpENodes>; null
? def t(s) :any { return dumpENodes(pp.run(s), stdout) }; null
? def tp(s) :any { return dumpENodes(pp.pattern(s, null, null), stdout) }; null

--- Function syntax ---

? t("pragma.enable(\"anon-lambda\"); fn { a }")
# stdout: SeqE. [] FunctionE.
#           []
#           NounE. a

? t("pragma.enable(\"anon-lambda\"); fn a { b }")
# stdout: SeqE. [] FunctionE.
#           [] FinalP.
#             NounE. a
#             null
#           NounE. b

? t("pragma.enable(\"anon-lambda\"); fn a, b { c }")
# stdout: SeqE. [] FunctionE.
#           []
#             FinalP.
#               NounE. a
#               null
#             FinalP.
#               NounE. b
#               null
#           NounE. c

? t("pragma.enable(\"anon-lambda\"); fn a, b, { c }")
# stdout: SeqE. [] FunctionE.
#           []
#             FinalP.
#               NounE. a
#               null
#             FinalP.
#               NounE. b
#               null
#           NounE. c

--- Sequence separators ---

No SeqExprs around single terminated exprs
  ? t("a;")
  # stdout: NounE. a
  ? t("{a;}")
  # stdout: HideE. NounE. a
  
Multiple separators of all types are allowed.
  ? t("a;;")
  # stdout: NounE. a
  ? t("a\n;")
  # stdout: NounE. a
  ? t("a;\n")
  # stdout: NounE. a
  ? t("a\n\n")
  # stdout: NounE. a

  ? t("{a;;}")
  # stdout: HideE. NounE. a
  ? t("{a\n;}")
  # stdout: HideE. NounE. a
  ? t("{a;\n}")
  # stdout: HideE. NounE. a
  ? t("{a\n\n}")
  # stdout: HideE. NounE. a

  ? t("{a\n\nb;;c;\n}")
  # stdout: HideE. SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c
  ? t("a\n\nb;;c;\n")
  # stdout: SeqE. []
  #           NounE. a
  #           NounE. b
  #           NounE. c

--- Acceptance of sequences everywhere they should be ---

NOTE: these tests were produced by inspection of antlr/e.g. They are not complete.

? t("__makeList(1;2)")
# stdout: FunCallE.
#           NounE. __makeList
#           [] SeqE. []
#             LiteralE. 1
#             LiteralE. 2

xxx Should we change the grammar so that pragmas don't create SeqExprs? '
? t("pragma.enable(\"trinary-define\"); def a := (1;2,3;4)")
# stdout: SeqE. [] DefrecE.
#           FinalP.
#             NounE. a
#             null
#           SeqE. []
#             LiteralE. 1
#             LiteralE. 2
#           SeqE. []
#             LiteralE. 3
#             LiteralE. 4

XXX ListExpr doesn't really belong here '
? t("[1;2 => 3]")
# stdout: MapE. [] ListE. []
#           SeqE. []
#             LiteralE. 1
#             LiteralE. 2
#           LiteralE. 3

? t("`${1;2}`")
# stdout: QuasiE.
#           null
#           [] QuasiE.Hole SeqE. []
#             LiteralE. 1
#             LiteralE. 2

--- Object expressions in high-precedence positions ---

Fails for the sake of sane precedence rules, even though it would be unambiguous, sort of.
? t("1 + def a := 2")
# problem: (unknown:1)@11: unexpected token: [":=",<159>,line=1,col=11]
XXX produce a nice error for this?

? t("a & def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ObjectHeadE.
#             
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []

? t("a & /**b*/def _ {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ObjectHeadE.
#             b
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []

? t("a & thunk {}")
# stdout: BinaryE.
#           &
#           NounE. a
#           [] ThunkE.
#             
#             NullE.

--- Result guards / easy-return ---

? t("pragma.disable(\"easy-return\")
>    pragma.enable(\"explicit-result-guard\")
>    def \"$a\"() {}")
# problem: (unknown:3)@13: You must specify a result guard or disable "explicit-result-guard".
XXX source position

? t("pragma.disable(\"easy-return\")
>    pragma.enable(\"explicit-result-guard\")
>    def \"$a\"{ to b() {} }")
# problem: (unknown:3)@19: You must specify a result guard or disable "explicit-result-guard".
XXX source position

? t("pragma.disable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def \"$a\"() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           $a
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             false

? t("pragma.disable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def \"$a\"{ to b() {} }")
# stdout: SeqE. [] ObjectHeadE.
#           
#           $a
#           MethodObject
#             null
#             []
#             [] ETo
#               
#               b
#               []
#               null
#               NullE.
#               false
#             []

? t("pragma.enable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def \"$a\"() {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           $a
#           FunctionObject
#             []
#             null
#             []
#             NullE.
#             true

? t("pragma.enable(\"easy-return\")
>    pragma.disable(\"explicit-result-guard\")
>    def \"$a\"{ to b() {} }")
# stdout: SeqE. [] ObjectHeadE.
#           
#           $a
#           MethodObject
#             null
#             []
#             [] ETo
#               
#               b
#               []
#               null
#               NullE.
#               true
#             []

--- Function expressions ---

? t("def \"$a\"() :b {}")
# stdout: ObjectHeadE.
#           
#           $a
#           FunctionObject
#             []
#             NounE. b
#             []
#             NullE.
#             false

? t("def \"$a\"() :b implements c {}")
# problem: (unknown:1)@26: The optional "function-implements" syntax is currently off.

? t("pragma.enable(\"function-implements\"); def \"$a\"() :b implements c {}")
# stdout: SeqE. [] ObjectHeadE.
#           
#           $a
#           FunctionObject
#             []
#             NounE. b
#             [] NounE. c
#             NullE.
#             false

--- modPow ---

? t("a ** b %% c")
# stdout: ModPowE.
#           NounE. a
#           NounE. b
#           NounE. c

Parentheses disable modPow form
? t("(a ** b) %% c")
# stdout: BinaryE.
#           %%
#           BinaryE.
#             **
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("a %% b ** c")
# stdout: BinaryE.
#           %%
#           NounE. a
#           [] BinaryE.
#             **
#             NounE. b
#             [] NounE. c

? t("a ** b % c")
# stdout: BinaryE.
#           %
#           BinaryE.
#             **
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("(a %% b) ** c")
# stdout: BinaryE.
#           **
#           BinaryE.
#             %%
#             NounE. a
#             [] NounE. b
#           [] NounE. c

? t("a %% (b ** c)")
# stdout: BinaryE.
#           %%
#           NounE. a
#           [] BinaryE.
#             **
#             NounE. b
#             [] NounE. c

--- CoerceExpr ---

? t("{a} :b")
# stdout: CoerceE.
#           HideE. NounE. a
#           NounE. b

? t("def _ {} :a")
# stdout: CoerceE.
#           ObjectHeadE.
#             
#             IgnoreP.
#             MethodObject
#               null
#               []
#               []
#               []
#           NounE. a

? t("a :b :c")
# problem: (unknown:1)@6: unexpected token: [":",<168>,line=1,col=6]
XXX prettier error

--- ForExpr ---

? t("for a => b in c { d }")
# stdout: ForE.
#           FinalP.
#             NounE. a
#             null
#           FinalP.
#             NounE. b
#             null
#           NounE. c
#           NounE. d
? t("for b in c { d }")
# stdout: ForE.
#           null
#           FinalP.
#             NounE. b
#             null
#           NounE. c
#           NounE. d

--- InterfaceExpr ---

XXX more tests (this section was written to test guardless ParamDesc)

? t("interface a { to b(c, d :e, _ :f, _) }")
# stdout: InterfaceE.
#           
#           FinalP.
#             NounE. a
#             null
#           null
#           []
#           []
#           [] MessageDescE.
#             
#             b
#             []
#               ParamDescE.
#                 c
#                 null
#               ParamDescE.
#                 d
#                 NounE. e
#               ParamDescE.
#                 null
#                 NounE. f
#               ParamDescE.
#                 null
#                 null
#             null

--- IntoExpr ---

? t("a into b")
# stdout: IntoE.
#           NounE. a
#           null
#           FinalP.
#             NounE. b
#             null

? t("a into ! (b) c")
# stdout: IntoE.
#           NounE. a
#           NounE. b
#           FinalP.
#             NounE. c
#             null

? t("a into ! b c")
# problem: (unknown:1)@10: expecting "(", found 'b'

IntoExpr has precedence immediately above sequences.

? t("a; def b := c into d; e")
# stdout: SeqE. []
#           NounE. a
#           IntoE.
#             DefrecE.
#               FinalP.
#                 NounE. b
#                 null
#               NounE. c
#               null
#             null
#             FinalP.
#               NounE. d
#               null
#           NounE. e

? t("a into b into c")
# stdout: IntoE.
#           IntoE.
#             NounE. a
#             null
#             FinalP.
#               NounE. b
#               null
#           null
#           FinalP.
#             NounE. c
#             null

--- Via-pattern ---

? tp("via (a) b")
# stdout: ViaP.
#           NounE. a
#           FinalP.
#             NounE. b
#             null

--- Miscellaneous ---

? t("a :b[c]")
# stdout: CoerceE.
#           NounE. a
#           GetE.
#             NounE. b
#             [] NounE. c

XXX test acceptance of line breaks everywhere
XXX general parser tests for everything

x ? t("")
x # stdout: 
