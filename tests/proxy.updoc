# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

EProxyResolver/EProxyHandler, or at least our version thereof

  ? pragma.syntax("0.9")

--- Far Ref

  ? var i := 0
  # value: 0

  ? def farHandler {
  >   to handleSendAll(verb, args) :any {
  >     println(`handleSendAll $verb $args`)
  >     return [i += 1, verb, args]
  >   }
  >   to handleSendAllOnly(verb, args) :any {
  >     println(`handleSendAllOnly $verb $args`)
  >     return [i += 1, verb, args] # should not be returned from the proxy
  >   }
  >   to handleResolution(newTarget) :any {
  >     println(`handleResolution $newTarget`)
  >   }
  > }
  # value: <farHandler>

The second argument to makeProxyResolver is the identity of the far reference, for which we use the farHandler itself for this test.

  ? def farResolver := makeProxyResolver(farHandler, farHandler)
  # value: <Proxy Resolver>
  
  ? def remote := farResolver.getProxy()
  # value: <Far ref>
  
  ? remote.hi()
  # problem: not synchronously callable: <Far ref>.hi()
  
  ? pragma.enable("accumulator")
  > accum [] for verb in ["isBroken", "isNear", "isEventual", "isFar", "isSettled", "isResolved", "optProblem"] { _.with(E.call(Ref, verb, [remote])) }
  # value: [false, false, true, true, true, true, null]

  ? def remoteKey := __equalizer.makeTraversalKey(remote)
  # value: <key:<Far ref>>

-- Send on Far ref

  ? def firstResponse := remote <- first()
  # value: <Promise>
  
  # stdout: handleSendAll first []
  #         
  
Notice that even though the handler is written to resolve it immediately, the response remains a promise during the first turn. This is done deliberately so that E-implemented proxies cannot have synchronous effects during an E.send.

  ? interp.waitAtTop(firstResponse)
  
  ? Ref.fulfillment(firstResponse)
  # value: [1, "first", []]

-- Send-only

  ? E.sendOnly(remote, "only", [])
  # stdout: handleSendAllOnly only []
  #         

-- Breaking Far ref

  ? [Ref.optProblem(remote), 
  >  farResolver.smash("gone away"),
  >  Ref.optProblem(remote)]
  # value: [null, null, problem: gone away]

  # stdout: handleResolution <ref broken by problem: gone away>
  #         
  
XXX should breakage be not synchronously visible instead?
  
  ? remote <- msg()
  # value: <ref broken by problem: gone away>

  confirm sameness as best we can
  ? __equalizer.makeTraversalKey(remote) == remoteKey
  # value: true

(The synchronous visibility of <- on a broken reference is a separate issue, and works the same way for Ref.broken/1)

--- handleResolution cases

handleResolution/1 is called in the event of a resolve or smash. The handler will no longer be invoked to handle sends.

The following tests are for that handleResolution is called in all cases, as this is nontrivial if the proxy doesn't currently exist.

  ? var expectResolution := null
  > def resolveTestHandler {
  >   to handleResolution(resolution) {
  >     println(`handleResolution($resolution), ${(resolution == expectResolution).pick("", "not ")}same`)
  >   }
  > }
  # value: <resolveTestHandler>

Promise resolution, no proxy

  ? def pr := makeProxyResolver(resolveTestHandler, null)
  # value: <Proxy Resolver>
  
  ? pr.resolve(expectResolution := 1)
  # stdout: handleResolution(1), same
  #         

Promise smash, no proxy

  ? def pr := makeProxyResolver(resolveTestHandler, null)
  # value: <Proxy Resolver>

  ? expectResolution := null
  > pr.smash("x")
  # stdout: handleResolution(<ref broken by problem: x>), not same
  #         

Identified smash, no proxy

  ? def pr := makeProxyResolver(resolveTestHandler, resolveTestHandler)
  # value: <Proxy Resolver>

  ? expectResolution := null; pr.smash("x")
  # stdout: handleResolution(<ref broken by problem: x>), not same
  #         

Identified smash, with proxy (so we can check)

  ? def pr := makeProxyResolver(resolveTestHandler, resolveTestHandler)
  # value: <Proxy Resolver>

  ? expectResolution := pr.getProxy(); pr.smash("x")
  # stdout: handleResolution(<ref broken by problem: x>), same
  #         

--- Remote Promise
  
  ? def promiseHandler { to handleResolution(_) :void {} }
  # value: <promiseHandler>
  
  ? def promiseResolver := makeProxyResolver(promiseHandler, null)
  # value: <Proxy Resolver>
  
  ? def remotePromise := promiseResolver.getProxy()
  # value: <Promise>
  
  ? remotePromise.hi()
  # problem: not synchronously callable: <Promise>.hi()
  
  ? pragma.enable("accumulator")
  > accum [] for verb in ["isBroken", "isNear", "isEventual", "isFar", "isSettled", "isResolved", "optProblem"] { _.with(E.call(Ref, verb, [remotePromise])) }
  # value: [false, false, true, false, false, false, null]
  
  ? promiseResolver.resolve(def promiseResolution {})
  
  ? remotePromise
  # value: <promiseResolution>
  
  ? remotePromise == promiseResolution
  # value: true
  
  ? accum [] for verb in ["isBroken", "isNear", "isEventual", "isFar", "isSettled", "isResolved", "optProblem"] { _.with(E.call(Ref, verb, [remotePromise])) }
  # value: [false, true, false, false, true, true, null]

--- Sameness of Far refs

  ? def stubHandler { to handleResolution(_) :void {} }
  # value: <stubHandler>

  different proxies, same identity
  ? makeProxyResolver(stubHandler, def fi1 {}).getProxy() == makeProxyResolver(stubHandler, fi1).getProxy()
  # value: true

  different proxies, different identity
  ? makeProxyResolver(stubHandler, fi1).getProxy() == makeProxyResolver(stubHandler, def fi2 {}).getProxy()
  # value: false

  different proxies, different instantiation of same Selfless identity
  ? makeProxyResolver(stubHandler, [fi1]).getProxy() == makeProxyResolver(stubHandler, [fi1]).getProxy()
  # value: true
  
  unresolved one
  ? makeProxyResolver(stubHandler, null).getProxy() == makeProxyResolver(stubHandler, [fi1]).getProxy()
  # problem: <InsufficientlySettledException: not sufficiently settled: <Promise> == <Far ref>>

  unresolved both
  ? makeProxyResolver(stubHandler, null).getProxy() == makeProxyResolver(stubHandler, null).getProxy()
  # problem: <InsufficientlySettledException: not sufficiently settled: <Promise> == <Promise>>

  unresolved-but-same
  ? (def pr := makeProxyResolver(stubHandler, null)).getProxy() == pr.getProxy()
  # value: true

--- Sameness of broken Far references

Setup

  ? def pr1 := makeProxyResolver(stubHandler, def sbfi {})
  # value: <Proxy Resolver>

  ? def pr2 := makeProxyResolver(stubHandler, sbfi)
  # value: <Proxy Resolver>

  ? def prO := makeProxyResolver(stubHandler, def sbfi2 {})
  # value: <Proxy Resolver>

  ? def [p1, p2, pO] := [pr1.getProxy(), pr2.getProxy(), prO.getProxy()]
  # value: [<Far ref>, <Far ref>, <Far ref>]
  
  ? p1 == p2
  # value: true
  
  ? p1 == pO
  # value: false

Resolving gives a specific identity, so it cannot be used.

  ? pr1.resolve(Ref.broken("yellow"))
  # problem: can't resolve a proxy ref with identity (<sbfi>) to <ref broken by problem: yellow>

Smashing does not, so it can.

XXX Is this consistent with E-on-Java? Is it correct? Is it good?

  ? for x in [pr1, pr2, prO] { x.smash("yellow") }

  ? p1
  # value: <ref broken by problem: yellow>
  
  ? p1 == p2
  # value: true

  ? p1 == pO
  # value: false

--- Odd cases

  Unsettled argument

  ? makeProxyResolver(stubHandler, Ref.promise())
  # problem: <NotSettledException: not settled: optIdentity [<Promise>, <Resolver>]>
  
  Duplicate smash
  
  ? def resolver := makeProxyResolver(farHandler, farHandler)
  # value: <Proxy Resolver>
  
  ? resolver.smash("foo")
  # stdout: handleResolution <ref broken by problem: foo>
  #         
  
  ? resolver.smash("bar")
  # problem: already resolved
  

XXX explicitly test hash code is preserved across breakage, so hash tables/TraversalKey etc. work
XXX sends
XXX optSealedDispatch/conformTo
XXX resolution to near/other-promise targets