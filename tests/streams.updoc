# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

  ? def ALL := EIO.getALL()


  ? def makeOutStreamShell := <elib:eio.makeOutStreamShell>
  # value: <makeOutStreamShell>
  
  ? def stream := makeOutStreamShell(float64, def streamBackend, def impl {
  >   to write(elements) :void { print(elements) }
  >   to flush() :void { print("flush") }
  > })
  # value: -><impl>

  ? stream.available()  
  # value: 0
  
  ? streamBackend.setAvailable(10)
  
  ? stream.available()
  # value: 10
  
  ? stream.write([1.0, 2.0, 3.0])
  # stdout: [1.0, 2.0, 3.0]
  
  ? stream.available()
  # value: 7
  
insufficient availability

  ? stream.write("abcdefgh")
  # problem: <UnavailableException: 8 elements cannot be written at this time (only 7)>
  
test ALL while writing
  
  ? streamBackend.setAvailable(ALL)
  
  ? stream.available() == ALL
  # value: true
  
  ? stream.write([1000.0])
  # stdout: [1000.0]
  
  ? stream.available() == ALL
  # value: true
  
misc methods

  ? stream.flush()
  # stdout: flush

  XXX impl should get to give an opinion
  ? stream.maxAvailable() == ALL
  # value: true
  
  XXX test that this is enforced
  ? stream.getElementType()
  # value: float64
  
  ? def terminator := stream.terminates()
  # value: <Promise>
  
  ? stream.isTerminated()
  # value: false
  
termination and consequences

  XXX Java FQN

  ? stream.fail("biff" :<type:java.lang.Exception>)
  # value: <ref broken by problem: biff>
  
  ? stream.fail("blaff" :<type:java.lang.Exception>)
  # problem: this resolver's ref has already been resolved, therefore cannot be resolved to <ref broken by problem: blaff>
  
  ? stream.close()
  # value: <ref broken by problem: biff>
  
  ? stream.write([])
  # problem: biff
  
  ? stream.flush()
  -- no effect
  
  XXX check that setAvailable may not now be used
  ? stream.available()
  # value: 0
  
  ? stream.getElementType()
  # value: float64
  
  ? [terminator, stream.terminates() == terminator]
  # value: [<ref broken by problem: biff>, true]
  
  ? stream.maxAvailable()
  # value: 0

closure (testing with fresh stream)

  ? def stream := makeOutStreamShell(float64, def streamBackend, def impl {
  >   to write(elements) :void { print(elements) }
  >   to flush() :void { print("flush") }
  > })
  # value: -><impl>
  
  ? def terminator := stream.terminates()
  # value: <Promise>
  
  ? stream.close()
  # value: true
  
  ? stream.close()
  # value: true
  
  ? stream.flush()
  -- no effect
  
  ? stream.write([])
  # problem: <UnavailableException: stream closed>

  ? stream.available()
  # value: 0
  
  ? stream.getElementType()
  # value: float64
  
  ? [terminator, stream.terminates() == terminator]
  # value: [true, true]
  
  ? stream.maxAvailable()
  # value: 0

whenAvailable

  ? def stream := makeOutStreamShell(float64, def streamBackend, def impl {
  >   to write(elements) :void { print(elements) }
  >   to flush() :void { print("flush") }
  > })
  # value: -><impl>
  
  ? stream.whenAvailable(0, thunk { print("wa1"); '1' })
  # stdout: wa1
  
  # value: '1'
  
  ? def wap2 := stream.whenAvailable(4, thunk { print("wa2"); '2' })
  # value: <Promise>

  ? stream.whenAvailable(4, thunk { print("wa3"); '3' })
  # problem: whenAvailable reactor <_> already registered
  
  ? streamBackend.setAvailable(2)

  ? streamBackend.setAvailable(6); "set"
  # stdout: wa2
  
  # value: "set"
  
  ? wap2
  # value: '2'

  ? def wap4 := stream.whenAvailable(7, thunk { throw("blargh") })
  # value: <Promise>
  
  ? streamBackend.setAvailable(7)
  
  ? E.toQuote(wap4)
  # value: "<ref broken by <sealed problem>>"
  
  ? wap4()
  # problem: blargh

XXX ejectors for kinds of failure from write()


--- Input streams ---

  ? def makeInStreamShell := <elib:eio.makeInStreamShell>
  # value: <makeInStreamShell>

  I expect to change these...
  ? def NOW := "NOW"; null
  ? def LATER := "LATER"; null
  ? def WAIT := "WAIT"; null
  ? def ADVANCE := "ADVANCE"; null
  ? def QUERY := "QUERY"; null
  ? def ELEMENTS := "ELEMENTS"; null
  ? def STATUS := "STATUS"; null

  read may return more elements than currently available
  tryAvailable exists so that stream#whenAvailable can create suction if the stream is lazy

  ? def buffer := [].diverge(int)
  > pragma.enable("accumulator")
  > def stream := makeInStreamShell(int, def streamBackend, def impl {
  >   to semiObtain(atLeast, var atMost, proceed, report) :any { 
  >     if (atLeast == ALL) { throw("XXX testing stream impl got atLeast ALL") }
  >     def n := if (atMost == ALL) { buffer.size() } \
  >                                 else { (atLeast + atMost) // 2 }
  >     def r := if (report == ELEMENTS) { buffer(0, n) }
  >     if (proceed == ADVANCE) { buffer(0, n) := []; streamBackend.setAvailable(buffer.size()) }
  >     return r
  >   }
  >   to tryAvailable(minimum) :void { println(`tryAvailable $minimum`) }
  > })
  # value: <-<impl>

Testing bad arguments to obtain:
  ? stream.obtain(-1, 10, NOW, ADVANCE, ELEMENTS)
  # problem: not in region
  ? stream.obtain(5, 4, NOW, ADVANCE, ELEMENTS)
  # problem: doesn't match any of [nullOk, (int >= 5)]
  ? stream.obtain(ALL, 10, NOW, ADVANCE, ELEMENTS) # XXX the specific error will change when non-erroneous ALL is supported
  # problem: the Null null doesn't coerce to an int
  ? stream.obtain(1, 1, 43, ADVANCE, ELEMENTS)
  # problem: must be one of ["NOW", "LATER", "WAIT"]: 43
  ? stream.obtain(1, 1, NOW, "foo", ELEMENTS)
  # problem: must be one of ["ADVANCE", "QUERY"]: "foo"
  ? stream.obtain(1, 1, NOW, ADVANCE, def el extends ELEMENTS {}) # XXX should this case be allowed instead?
  # problem: must be one of ["ELEMENTS", "STATUS"]: <el>

-- actual usage

  ? stream.whenAvailable(1, thunk { print("first inStream whenAvailable") })
  # value: <Promise>

  ? stream.obtain(5, 15, NOW, ADVANCE, ELEMENTS)
  # problem: <UnavailableException: 5 elements cannot be read at this time (only 0)>
  
  ? buffer.append(__makeList.fromIteratableValues(1..18))
  ? streamBackend.setAvailable(buffer.size())
  # stdout: first inStream whenAvailable
  
  ? stream.obtain(5, 15, NOW, ADVANCE, ELEMENTS)
  # value: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  ? stream.obtain(4, 6, NOW, QUERY, ELEMENTS)
  # value: [11, 12, 13, 14, 15]
  
  ? stream.obtain(4, 8, NOW, QUERY, ELEMENTS)
  # value: [11, 12, 13, 14, 15, 16]
  
  ? def t := stream.obtain(6, 6, NOW, ADVANCE, STATUS)
  # value: <Promise>
  
  ? t == stream.terminates()
  # value: true
  
testing schedule==LATER
  
  ? stream.available()
  # value: 2
  
 peek
  ? stream.obtain(0, ALL, NOW, QUERY, ELEMENTS)
  # value: [17, 18]
  
 requesting more elements than currently available
  ? def elementsVow := stream.obtain(3, 6, LATER, ADVANCE, ELEMENTS)
  # value: <Promise>
  
 they are visibly claimed:
  ? stream.available()
  # value: 0
  ? stream.obtain(0, ALL, NOW, QUERY, ELEMENTS)
  # value: []
  ? stream.obtain(1, ALL, NOW, QUERY, ELEMENTS)
  # problem: <UnavailableException: 1 elements cannot be read at this time (2 elements are claimed by 1 LATER requests)>

XXX proper plurals

  
This whenAvailable does not trigger immediately, even though there are 2 elements actually in the stream, because they have been claimed by the obtain for 3..6.

  ? stream.whenAvailable(2, thunk { print("whenAvailable from 17...") })
  # value: <Promise>
  
  ? elementsVow
  # value: <Promise>

After enough elements are available, the promise will be resolved.
  
  ? buffer.append([303, 116, 191, 222])
  ? streamBackend.setAvailable(buffer.size())
  # stdout: whenAvailable from 17...
  
  ? elementsVow
  # value: [17, 18, 303, 116]
  
Termination

  ? def pwA := stream.whenAvailable(100, thunk {print(`termination test whenAvailable -- ${stream.terminates()}`); 0})
  # value: <Promise>

  ? def poAE := stream.obtain(50, 50, LATER, ADVANCE, ELEMENTS)
  # value: <Promise>

  ? def poAS := stream.obtain(50, 50, LATER, ADVANCE, STATUS)
  # value: <Promise>

  ? interp.waitAtTop(pwA)
  > stream.fail("boo")
  # value: <ref broken by problem: boo>

  # stdout: termination test whenAvailable -- <ref broken by problem: boo>

  ? [pwA, poAE, poAS]
  # value: [0, <ref broken by problem: boo>, <ref broken by problem: boo>]

XXX write tests that STATUS is correct: according to http://www.erights.org/elib/concurrency/eio/obtaining.html the return value of STATUS is "the termination status of the stream *after* these elements have been obtained" (emphasis mine)

XXX for both directions of streams: notify impl synchronously upon termination? (terminator provides eventual-or-poll notification)
XXX notification by impl of closure -- needed? convenient?
  possibly in the form "no more elements will become available than currently"
XXX InStream sugar methods
XXX InStream#remaining