# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

? 1 <- add(2)
# value: <Promise>

? def r := 1 <- add(2)
# value: <Promise>

? [interp.waitAtTop(r)]
# value: [null]

? r
# value: 3

? def x := x
# value: <ref broken by problem: <ViciousCycleException: Ref loop>>

? def r := 1 <- add(2) <- add(3)
# value: <Promise>

? [interp.waitAtTop(r)]
# value: [null]

? r
# value: 6

? def r := 1 <- boom()
# value: <Promise>

? [interp.waitAtTop(r)]
# value: [null]

? Ref.isBroken(r)
# value: true

XXX tests for coercion of E#send arguments

Ref#whenResolved/2

  updoc stdout from 'background' turns is not reliable
  ? var out := ""; def report() :void { print(out); out := "" }
  # value: <report>

  ? def v
  # value: <Resolver>
  
  ? def testDone := Ref.whenResolved(v, def _(vv) :void { out += ` 1. $v -> $vv` })
  # value: <Promise>
  
  ? bind v := 0; interp.waitAtTop(testDone)
  
  ? report()
  # stdout:  1. 0 -> 0
  
  ? def doubleBouncer { 
  >   to __whenMoreResolved(r) :void { 
  >     r <- ()
  >     r <- ()
  >   }
  > }
  # value: <doubleBouncer>
  
  ? interp.waitAtTop(Ref.whenResolved(__identityFunc <- (doubleBouncer), def _(vv) :void { out += ` 2. $doubleBouncer -> $vv` }))
  
  ? report()
  # stdout:  2. <doubleBouncer> -> <doubleBouncer>
  
  x This old test code is from when __whenMoreResolved reactors got the reference as an argument. As they no longer do, the misbehavior this is testing can no longer be expressed. xxx delete? -- kpreid 2004-07-07
  x 
  x ? def redirector {
  x >   to __whenMoreResolved(r) :void {
  x >     r <- (43)
  x >   }
  x > }
  x # value: <redirector>
  x 
  x ? interp.waitAtTop(Ref.whenResolved(__identityFunc <- (redirector), def _(vv) :void { out += ` 3. $redirector -> $vv` }))
  x 
  x ? report()
  x # stdout:  3. <redirector> -> <redirector>
  x 
  x ? def doubleRedirector {
  x >   to __whenMoreResolved(r) :void {
  x >     r <- (redirector)
  x >   }
  x > }
  x # value: <doubleRedirector>
  x 
  x ? interp.waitAtTop(Ref.whenResolved(__identityFunc <- (doubleRedirector), def _(vv) :void { out += ` 4. $doubleRedirector -> $vv` }))
  x 
  x ? report()
  x # stdout:  4. <doubleRedirector> -> <doubleRedirector>
