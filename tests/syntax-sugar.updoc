# Copyright 2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

These are tests specifically of the text->Kernel-E stages, skipping evaluation and the intermediate unexpanded form; however, the intent is primarily to test expansion, not the parser.

  ? def t := <import:org.cubik.cle.prim.parser>; null
  ? def tp(pat) :any { return t.pattern(pat, null) }; null

Where headings are in quotes, it indicates that the names are those I invented for the nodes representing the unexpanded syntax, which are not reified in E-on-Java and have no names.

'AccumExpr'

  ? t("pragma.enable(\"accumulator\"); accum a if (b) { _.c(d) }")
  # value: e`def var accum__1 := a
  #        if (b) {
  #            accum__1 := accum__1.c(d)
  #        } else {
  #            null
  #        }
  #        accum__1`

  ? t("pragma.enable(\"accumulator\"); accum a if (b) { _ + c }")
  # value: e`def var accum__1 := a
  #        if (b) {
  #            accum__1 := accum__1.add(c)
  #        } else {
  #            null
  #        }
  #        accum__1`

  ? t("pragma.enable(\"accumulator\"); accum a while (b) { _.c(d) }")
  # value: e`def var accum__1 := a
  #        escape __break {
  #            __loop.run(def _ {
  #                
  #                method run() :boolean {
  #                    if (b) {
  #                        escape __continue {
  #                            accum__1 := accum__1.c(d)
  #                        }
  #                        true
  #                    } else {
  #                        false
  #                    }
  #                }
  #            })
  #        }
  #        accum__1`
  
  ? t("pragma.enable(\"accumulator\"); accum a for b => c in d { _.e(f) }")
  # value: e`def var accum__1 := a
  #        escape __break {
  #            def var valid__2 := true
  #            try {
  #                d.iterate(def _ {
  #                    
  #                    method run(key__3, value__4) {
  #                        require.run(valid__2, "For-loop body isn't valid after for-loop exits.")
  #                        escape __continue {
  #                            escape skip__5 {
  #                                def b := (key__3, skip__5)
  #                                def c := (value__4, skip__5)
  #                                accum__1 := accum__1.e(f)
  #                            }
  #                            null
  #                        }
  #                    }
  #                })
  #            } finally {
  #                valid__2 := false
  #            }
  #            null
  #        }
  #        accum__1`

'BinaryExpr'

  ? t("a + b")
  # value: e`a.add(b)`
  
  Disabled for now till the final fate of +(,) is decided
  x ? t("a + (b, c)")
  x # value: e`a.add(b, c)`
  
  ? t("a..b")
  # value: e`__makeOrderedSpace.op__thru(a, b)`

  ? t("a..!b")
  # value: e`__makeOrderedSpace.op__till(a, b)`
  
  XXX test all binary ops for correct matching verbs

'CoerceExpr'

  ? t("a :b")
  # value: e`ValueGuard.coerce(b, null).coerce(a, null)`

  XXX order of evaluation reversal

'CompareExpr'

  ? t("a < b")
  # value: e`__comparer.lessThan(a, b)`

'ConditionalExpr'

  ? t("(def a := b) || (def c := d)")
  # value: e`if (def a := b) {
  #            null =~ [&c]
  #            __makeList.run(&c, &a)
  #        } else {
  #            if (def c := d) {
  #                null =~ [&a]
  #                __makeList.run(&c, &a)
  #            } else {
  #                null
  #            }
  #        } =~ [&c, &a]`
  
  ? t("(def a := b) && (def c := d)")
  # value: e`if (def a := b) {
  #            if (def c := d) {
  #                __makeList.run(&c, &a)
  #            } else {
  #                null
  #            }
  #        } else {
  #            null
  #        } =~ [&c, &a]`
  
  XXX 'null =~' for failure leads to cryptic failures (inherited from EoJ)

  Bug test: temporary names inside a ConditionalExpr would fail
  ? t("(def ==x := x) && true")
  # value: e`if (def __1 ? __equalizer.sameEver(__1, x) := x) {
  #            if (true) {
  #                __makeList.run(&__1)
  #            } else {
  #                null
  #            }
  #        } else {
  #            null
  #        } =~ [&__1]`

'CurryExpr'

  ? t("pragma.enable(\"verb-curry\"); a.b")
  # value: e`__makeVerbFacet.curryCall(a, "b")`

  ? t("pragma.enable(\"verb-curry\"); a <- b")
  # value: e`__makeVerbFacet.currySend(a, "b")`

'DefrecExpr'

  ? t("def a := b")
  # value: e`def a := b`

  ? t("def [a, b] := [b, c]")
  # value: e`def [b__1, bR__2] := Ref.promise()
  #        def value__3 := def [a, b] := __makeList.run(b__1, c)
  #        bR__2.resolve(b)
  #        value__3`

'ExitExpr'

  ? t("return")
  # value: e`__return.run()`

  ? t("return a")
  # value: e`__return.run(a)`

  ? t("break a")
  # value: e`__break.run(a)`

  ? t("continue a")
  # value: e`__continue.run(a)`

'ForExpr'

  ? t("for a => b in c { d }")
  # value: e`escape __break {
  #            def var valid__1 := true
  #            try {
  #                c.iterate(def _ {
  #                    
  #                    method run(key__2, value__3) {
  #                        require.run(valid__1, "For-loop body isn't valid after for-loop exits.")
  #                        escape __continue {
  #                            escape skip__4 {
  #                                def a := (key__2, skip__4)
  #                                def b := (value__3, skip__4)
  #                                d
  #                            }
  #                            null
  #                        }
  #                    }
  #                })
  #            } finally {
  #                valid__1 := false
  #            }
  #            null
  #        }`

  XXX look into extracting part of the for-loop expansion into a function - the revocation logic at least
  
'ForwardExpr'

  ? t("def a")
  # value: e`def [a, a__Resolver] := Ref.promise()
  #        a__Resolver`
  
  Anything that expands to a noun is allowed.
  ? t("def <a>")
  # value: e`def [a__uriGetter, a__uriGetter__Resolver] := Ref.promise()
  #        a__uriGetter__Resolver`

'InterfaceExpr'

  ? t("interface a {}")
  # value: e`def a := {
  #            __makeProtocolDesc.run(null, meta.context().getFQNPrefix().add("a__T"), __makeList.run(), __makeList.run(), __makeList.run())
  #        }`
    
  ? t("interface \"a\" {}")
  # value: e`{
  #            __makeProtocolDesc.run(null, "a", __makeList.run(), __makeList.run(), __makeList.run())
  #        }`
  
  ? t("interface \"$a\" {}")
  # value: e`{
  #            __makeProtocolDesc.run(null, meta.context().getFQNPrefix().add("a"), __makeList.run(), __makeList.run(), __makeList.run())
  #        }`
    
  ? t("/**hi*/ interface \"a\" {}")
  # value: e`{
  #            __makeProtocolDesc.run("hi", "a", __makeList.run(), __makeList.run(), __makeList.run())
  #        }`

  ? t("/***/ interface \"a\" {}")
  # value: e`{
  #            __makeProtocolDesc.run("", "a", __makeList.run(), __makeList.run(), __makeList.run())
  #        }`
    
  ? t("interface a { to b(c :d) :e
  >                  to f() }")
  # value: e`def a := {
  #            __makeProtocolDesc.run(null, meta.context().getFQNPrefix().add("a__T"), __makeList.run(), __makeList.run(), __makeList.run({
  #                __makeMessageDesc.run("", "b", __makeList.run(__makeParamDesc.run("c", d)), e)
  #            }, {
  #                __makeMessageDesc.run("", "f", __makeList.run(), null)
  #            }))
  #        }`

  ? t("interface a guards b { to c(d :e) :f 
  >                           to g() }")
  # value: e`(def [a, b] := {
  #            __makeProtocolDesc.makePair(null, meta.context().getFQNPrefix().add("a__T"), __makeList.run(), __makeList.run(), __makeList.run({
  #                __makeMessageDesc.run("", "c", __makeList.run(__makeParamDesc.run("d", e)), f)
  #            }, {
  #                __makeMessageDesc.run("", "g", __makeList.run(), null)
  #            }))
  #        }).get(0)`

  ? t("interface \"a\" guards b {}")
  # value: e`(def [_, b] := {
  #            __makeProtocolDesc.makePair(null, "a", __makeList.run(), __makeList.run(), __makeList.run())
  #        }).get(0)`

'ListExpr'

  ? t("[]")
  # value: e`__makeList.run()`

  ? t("[a, b]")
  # value: e`__makeList.run(a, b)`

'MapExpr'

  ? t("[a => b]")
  # value: e`__makeMap.fromPairs(__makeList.run(__makeList.run(a, b)))`

  ? t("[=> a]")
  # value: e`__makeMap.fromPairs(__makeList.run(__makeList.run("a", a)))`

  ? t("[=> &a]")
  # value: e`__makeMap.fromPairs(__makeList.run(__makeList.run("&a", &a)))`

'MismatchExpr'

  ? t("a !~ b")
  # value: e`(a =~ b).not()`

'NKAssignExpr'

  ? t("a := b")
  # value: e`a := b`
  
  ? t("a(b, c) := d")
  # value: e`a.setRun(b, c, def ares__1 := d)
  #        ares__1`
  
  ? t("a[b, c] := d")
  # value: e`a.put(b, c, def ares__1 := d)
  #        ares__1`
  
  ? t("a.getFoo(b, c) := d")
  # value: e`a.setFoo(b, c, def ares__1 := d)
  #        ares__1`
  
  ? t("a.e(b, c) := d")
  # problem: assignment can only be done to nouns and collection elements (not "e" call)
  
  ? t("<a:b> := c")
  # value: e`a__uriGetter.put("b", def ares__1 := c)
  #        ares__1`
  
  XXX unary-star assignments?

'NKObjectExpr'

  base case
  ? t("def \"a\" {}")
  # value: e`def "a" {
  #        }`
  
  named
  ? t("def a {}")
  # value: e`def a := def "$a__C" {
  #        }`
  
  named with recursion (implemented by DefrecExpr)
  ? t("def a { method run() :any { a } }")
  # value: e`def [a__1, aR__2] := Ref.promise()
  #        def value__3 := def a := def "$a__C" {
  #            
  #            method run() :any {
  #                a__1
  #            }
  #        }
  #        aR__2.resolve(a)
  #        value__3`
  
  parent
  ? t("def \"a\" extends b {}")
  # value: e`{
  #            def super := b
  #            def "a" {
  #                match message__1 {
  #                    E.callWithPair(super, message__1)
  #                }
  #            }
  #        }`

  parent with reference to name
  ? t("def a extends b(a) {}")
  # value: e`def [a__1, aR__2] := Ref.promise()
  #        def value__3 := def a := {
  #            def super := b.run(a__1)
  #            def "$a__C" {
  #                match message__4 {
  #                    E.callWithPair(super, message__4)
  #                }
  #            }
  #        }
  #        aR__2.resolve(a)
  #        value__3`
  
'NullExpr'

  ? t("{}")
  # value: e`{
  #            null
  #        }`

'PrefixExpr'

  ? t("!a")
  # value: e`a.not()`

'PropertyExpr'

  ? t("pragma.enable(\"dot-props\"); a::b")
  # value: e`a.__getPropertySlot("b").getValue()`
  
  ? t("pragma.enable(\"dot-props\"); a::&b")
  # value: e`a.__getPropertySlot("b")`
  
  ? t("pragma.enable(\"dot-props\"); a::\"b\"")
  # value: e`a.__getPropertySlot("b").getValue()`
  
  ? t("pragma.enable(\"dot-props\"); a::&\"b\"")
  # value: e`a.__getPropertySlot("b")`

'QuasiExpr'

  ? t("` a $b ${\"c\"} $\\n $$ `` @@ `")
  # value: e`simple__quasiParser.valueMaker(" a ${0} ${1} 
  #         $$ ` @@ ").substitute(__makeList.run(b, "c"))`

  ? tp("` a $b ${\"c\"} @d @{[e]} $\\n $$ `` @@ `")
  # value: epatt`co__1 :__MatchContext ? (def [sp__2, ej__3] := co__1
  #        simple__quasiParser.matchMaker(" a ${0} ${1} @{0} @{1} 
  #         $$ ` @@ ").matchBind(__makeList.run(b, "c"), sp__2, ej__3) =~ [d, [e]])`

  ? t("a`b`")
  # value: e`a__quasiParser.valueMaker("b").substitute(__makeList.run())`

'RangeExpr': see 'BinaryExpr' for now

'SameExpr'
  
  ? t("a == b")
  # value: e`__equalizer.sameEver(a, b)`
  
  ? t("a != b")
  # value: e`__equalizer.sameEver(a, b).not()`

'SendExpr'

  ? t("a <- b(c)")
  # value: e`E.send(a, "b", __makeList.run(c))`

  ? t("a <- \"b\"(c)")
  # value: e`E.send(a, "b", __makeList.run(c))`

  ? t("a <- (b)")
  # value: e`E.send(a, "run", __makeList.run(b))`

'SwitchExpr'
  
  ? t("switch (x) { match [a] { b } match c { d } }")
  # value: e`{
  #            def specimen__1 := x
  #            if (specimen__1 =~ [a]) {
  #                b
  #            } else {
  #                if (specimen__1 =~ c) {
  #                    d
  #                } else {
  #                    throw.run("no match: ".add(specimen__1))
  #                }
  #            }
  #        }`
  
  XXX should be throw.run(__switchMatchError(...)) or similar, so that we're not stringifying the specimen '
  
'ThunkExpr'

  ? t("thunk {}")
  # value: e`def _ {
  #            
  #            method run() {
  #                null
  #            }
  #        }`
  
  ? t("thunk { a }")
  # value: e`def _ {
  #            
  #            method run() {
  #                a
  #            }
  #        }`
  
  x ? t("thunk implements a { b }")
  x # syntax error: 
  
  ? t("/** a */ thunk { b }")
  # value: e`def _ {
  #            
  #            /** a */
  #            method run() {
  #                b
  #            }
  #        }`

'UpdateExpr'

  ? t("a += b")
  # value: e`a := a.add(b)`
  
  See above about the related BinaryExpr
  x ? t("a += (b, c)")
  x # value: e`a := a.add(b, c)`
  
  ? t("a b= c")
  # value: e`a := a.b(c)`
  
  ? t("a b= (c)")
  # value: e`a := a.b(c)`
  
  ? t("a b= (c, d)")
  # value: e`a := a.b(c, d)`
  
  ? t("a b= a")
  # value: e`a := a.b(a)`
  
  XXX these syntax-level tests don't test the result of arbitrary children to UpdateExpr '

'URIExpr'

  ? t("<a:b>")
  # value: e`a__uriGetter.get("b")`
  
  ? t("<A:B>")
  # value: e`a__uriGetter.get("B")`
  
  ? t("<ab:c>")
  # value: e`ab__uriGetter.get("c")`

  ? t("<ab:c:d>")
  # value: e`ab__uriGetter.get("c:d")`

'URISchemeExpr'

  ? t("<a>")
  # value: e`a__uriGetter`

  ? t("<A>")
  # value: e`a__uriGetter`

  ? t("<svn+ssh>")
  # value: e`::"svn+ssh__uriGetter"`

  ? try { t("<0>") } catch _ {true}
  # value: true
  
  ? t("<a+90-.>")
  # value: e`::"a+90-.__uriGetter"`

'WhileExpr'

  ? t("while (a) { b }")
  # value: e`escape __break {
  #            __loop.run(def _ {
  #                
  #                method run() :boolean {
  #                    if (a) {
  #                        escape __continue {
  #                            b
  #                        }
  #                        true
  #                    } else {
  #                        false
  #                    }
  #                }
  #            })
  #        }`

'BindPattern'  

  ? tp("bind a")
  # value: epatt`a__1 ? (a__Resolver.resolve(a__1)
  #        true)`

  ? tp("bind a :b")
  # value: epatt`a__1 :b ? (a__Resolver.resolve(a__1)
  #        true)`

  Anything that expands to a noun is allowed.
  ? tp("bind <a> :b")
  # value: epatt`a__uriGetter__1 :b ? (a__uriGetter__Resolver.resolve(a__uriGetter__1)
  #        true)`


'MapPattern'
  
  ? tp("[\"a\" => b]")
  # value: epatt`map__1 ? (map__1.optExtract("a") =~ [b, map__2 ? __comparer.asBigAs(map__2.size(), 0)])`
  
  ? tp("[(a) => b]")
  # value: epatt`map__1 ? (map__1.optExtract(a) =~ [b, map__2 ? __comparer.asBigAs(map__2.size(), 0)])`
  
  ? tp("[=> a]")
  # value: epatt`map__1 ? (map__1.optExtract("a") =~ [a, map__2 ? __comparer.asBigAs(map__2.size(), 0)])`

  ? tp("[\"a\" => b := c]")
  # value: epatt`map__1 ? (map__1.extract("a", c) =~ [b, map__2 ? __comparer.asBigAs(map__2.size(), 0)])`

  XXX expansion to be changed to not use such-that

'SamePattern'

  ? tp("==x")
  # value: epatt`__1 ? __equalizer.sameEver(__1, x)`

'TailPattern': not testable

'FunctionScript'

  ? t("/** a */ def b() :c { d }")
  # value: e`def b := def "$b__C" {
  #            
  #            /** a */
  #            method run() :c {
  #                escape __return {
  #                    d
  #                }
  #            }
  #        }`

'ETo'

  ? t("def a { to b() :c { d } }")
  # value: e`def a := def "$a__C" {
  #            
  #            method b() :c {
  #                escape __return {
  #                    d
  #                }
  #            }
  #        }`
  
XXX test temporary name rules
XXX do node-based tests for FunctionScript, TailPattern, UpdateExpr since those aren't quite fully tested just from syntax '