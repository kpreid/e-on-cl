# Copyright 2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

  ? def makeFlexMap := <elib:tables.makeFlexMap>; null
  ? def deSubgraphKit := <elib:serial.deSubgraphKit>; null
  ? def makeCycleBreaker := <elib:tables.makeCycleBreaker>; null
  ? def Throwable := <type:java.lang.Throwable>; null

In this file, we test the implementation of the CapTP operations and associated state.

  ? def makeCapTPConnection := <import:net.captp.comm.makeCapTPConnection>
  # value: <makeCapTPConnection>
  
  ? def makeSwissTable := <import:net.captp.tables.makeSwissTable>
  # value: <makeSwissTable>
  
  ? def nonceLocatorIndex := 0; null
  ? def nullSwissNumber := 0; null
  
Test framework:

An mock finalization interface, with operations to trigger finalization of obects created in a particular time period:
  
  ? def finalizers := [].asMap().diverge()
  > var fIndex := 0
  > def pseudoWhenGarbage(ref, reactor) {
  >   #traceln(`Adding finalizer for $ref -> $reactor`)
  >   finalizers[fIndex += 1] := [ref, reactor]
  > }
  > def clearFinalizers() { finalizers.removeAll() }
  > def runFinalizers() {
  >   for i => [_, reactor] in finalizers {
  >     #traceln(`Running $reactor`)
  >     reactor <- ()
  >     finalizers.removeKey(i)
  >   }
  > }
  > null

Objects to represent the descriptors used by CapTP for connection-spanning references:

  ? def descs {
  >   match [v, a] { 
  >     def generic {
  >       to __printOn(out :TextWriter) { 
  >         out.print(v, "Desc")
  >         a.printOn("(", ", ", ")", out)
  >       }
  >       to __optUncall() { return [descs, v, a] }
  >     }
  >   }
  > }; null

LocatorUnum presences:

  ? def locatorUnumLocal {}
  > def locatorUnumRemote {}
  > null

Data-E setup:
  
  ? def [testGraphRecognizer, testBuilderMaker] := {
  >   def scope := deSubgraphKit.getDefaultScope() | [
  >     "CapTP_1_descs" => descs,
  >     "CapTP_1_locatorUnum" => locatorUnumRemote,
  >     => Ref,
  >     => <import>]
  >   [deSubgraphKit.makeRecognizer(null, makeCycleBreaker.byInverting(scope)),
  >    fn { deSubgraphKit.makeBuilder(scope) }]
  > }; null

To make the tests' use of indexes and swiss numbers independent of each other, we set up a new connection repeatedly using this function.

  > def makeTestConnection() {
    
Deterministic mock RNG. Its output will mostly appear in these tests hashed:
  10000001.cryptoHash() == 382064925828890872342377433413917253333972024416
  10000002.cryptoHash() == 1033912670282953026478972818820010722176128073325
  10000003.cryptoHash() == 47255196895205160731987244561159478631887357377

  >   var i := 10000000
  >   def pseudoEntropy {
  >     to nextSwiss() { return (i += 1) }
  >   }
  >
  >   def swissTable := makeSwissTable(pseudoEntropy, makeFlexMap, makeFlexMap)
  >     
  >   def [r, makeIncomingBuilder, rnl] := makeCapTPConnection(
  >     def outgoing { match msg { println(msg) }},
  >     testBuilderMaker,
  >     swissTable,
  >     locatorUnumLocal,
  >     pseudoWhenGarbage)

buildIn takes an object in our test environment, containing objects made by 'descs' above, and transforms them as a CapTP wire protocol unserializer would.

  >   def buildIn(obj) {
  >     return testGraphRecognizer.recognize(obj, makeIncomingBuilder())
  >   }; null
  >   return [swissTable, r, rnl, buildIn]
  > }; null
  
--- Incoming DeliverOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

At this point, the only thing the remote side can possibly do is close the connection or talk to the NonceLocator, which is at the well-known position 0. We'll ask it for null, which has the well-known swiss number 0.

The index provided is negative because it is chosen by the remote side. <http://www.erights.org/elib/distrib/captp/4tables.html>

The 2-cycle delay on the redirector reports is because there is first a send of answer <- __whenMoreResolved(redirector) followed by the __whenMoreResolved's response send.


  ? receiver.Deliver(-1, 
  >                  buildIn(descs.NewFar(1, 81479683)),
  >                  nonceLocatorIndex, 
  >                  "lookupSwiss",
  >                  buildIn([nullSwissNumber, null]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [null]]]
  #         

null should now be present in the connection's answers table at -1.

  ? receiver.Deliver(-2,
  >                  buildIn(descs.Import(1)),
  >                  -1,
  >                  "__getAllegedType",
  >                  buildIn([]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         
  
  ? receiver.Deliver(-3,
  >                  buildIn(descs.Import(1)),
  >                  -2,
  >                  "getFQName",
  >                  buildIn([]))
  ?
  # stdout: ["DeliverOnly", [1, "run", ["org.cubik.cle.prim.null"]]]
  #         

Positive/zero answer index is an error:

  ? receiver.Deliver(0, buildIn(descs.Import(1)), -2, "getFQName", buildIn([]))
  # problem: 0 is not in the region -2147483648..!0

  ? receiver.Deliver(1, buildIn(descs.Import(1)), -2, "getFQName", buildIn([]))
  # problem: 1 is not in the region -2147483648..!0

Missing recipient:

  ? receiver.Deliver(-1, buildIn(descs.Import(1)), -999, "getFQName", buildIn([]))
  # problem: 999 not alloced in AnswersTable__1

--- Incoming DeliverOnlyOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

2-cycle delay on this test because the reactor invocation is itself a send.

Delivery to the NonceLocator:

  ? receiver.DeliverOnly(0,
  >                      "__whenMoreResolved",
  >                      buildIn([descs.NewFar(1, 329849023489032)]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [ImportDesc(0)]]]
  #         

Delivery to an answer, creating the answer first:

  ? receiver.Deliver(-1, buildIn(descs.NewFar(2, 78897982443232)), 
  >                  0, "__getAllegedType", buildIn([]))
  ?
  # stdout: ["DeliverOnly", [2, "run", [NonceLocator]]]
  #         

  ? receiver.DeliverOnly(-1,
  >                      "__whenMoreResolved",
  >                      buildIn([descs.Import(1)]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [NonceLocator]]]
  #         

Delivery to an import:

  ? receiver.DeliverOnly(-1,
  >                      "__whenMoreResolved",
  >                      buildIn([descs.Import(1)]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [NonceLocator]]]
  #         

--- Incoming GCExportOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

To test GCExportOp, we must first export something.

  ? E.sendOnly(remoteNonceLocator, "exportTest", [def exported(x) {println(x)}])
  ?
  # stdout: ["DeliverOnly", [0, "exportTest", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

wireDelta of 0 should have no effect.

  ? receiver.GCExport(1, 0)
  ? receiver.DeliverOnly(1, "run", buildIn(["still here"]))
  # stdout: still here
  #         
  
wireDelta of 1 should delete the export.

  ? receiver.GCExport(1, 1)
  ? receiver.DeliverOnly(1, "run", buildIn(["gone"]))
  # problem: 1 not alloced in ExportsTable__1

A reference is collected once the sum of wireDeltas in all received GCExport messages exceeds the number of times it is exported. Here's a multiple export:

  ? E.sendOnly(remoteNonceLocator, "exportTest2a", [exported])
  ?
  # stdout: ["DeliverOnly", [0, "exportTest2a", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

(The NewFarDesc's index is the same because 1 is at the head of the exports table's free list, not because of any deliberate relationship.)

  ? E.sendOnly(remoteNonceLocator, "exportTest2b", [exported])
  > E.sendOnly(remoteNonceLocator, "exportTest2c", [exported])
  ?
  # stdout: ["DeliverOnly", [0, "exportTest2b", [ImportDesc(1)]]]
  #         ["DeliverOnly", [0, "exportTest2c", [ImportDesc(1)]]]
  #         

wireDelta of 1 should have no effect (export count now 2).

  ? receiver.GCExport(1, 1)
  ? receiver.DeliverOnly(1, "run", buildIn(["still here #2"]))
  # stdout: still here #2
  #         
  
Additional wireDelta of 2 should balance the three previous references.

  ? receiver.GCExport(1, 2)
  ? receiver.DeliverOnly(1, "run", buildIn(["gone #2"]))
  # problem: 1 not alloced in ExportsTable__1


--- Incoming GCAnswerOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

Create an answer.

  ? receiver.Deliver(-1, buildIn(descs.Incoming(0)), 0, "__getAllegedType", buildIn([]))

Deliveries to the answer are possible now:

  ? receiver.DeliverOnly(-1,
  >                      "__whenMoreResolved",
  >                      buildIn([descs.NewFar(1, 3124570689423516780)]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [NonceLocator]]]
  #         

but not after GCAnswerOp:

  ? receiver.GCAnswer(-1)
  ? receiver.DeliverOnly(-1,
  >                      "__whenMoreResolved",
  >                      buildIn([descs.Import(1)]))
  # problem: 1 not alloced in AnswersTable__1

--- Incoming ShutdownOp ---

XXX do this (shut down connection iff no more messages than the specified count have been sent by the recipient). Must not be visible to code. Note that 

(IRC log from July 28, 2007)
<markmiller> The funny case is messages to be sent to zero when a shutdown might happen
<markmiller> These need to be buffered, so that if a shutdown does happen, that can be resent transparently on a newly formed connection.
<kpreid> ow
<markmiller> This is much of why it was never fully implemented.
<kpreid> whereas in the current impls, it's essentially a connection-specific always-live-ref, yes?
<markmiller> GCing connections seems to be hard
<markmiller> yes

--- Incoming TerminatedOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

There are several cases to check the behavior of:

Imported far ref:
  
  ? def outgoingFar := remoteNonceLocator <- getTerminatedTestRef1()
  # value: <Promise>
  
  ?
  # stdout: ["Deliver", [-1, NewFarDesc(1, 382064925828890872342377433413917253333972024416), 0, "getTerminatedTestRef1", []]]
  #         
  
  ? receiver.DeliverOnly(1, "run", buildIn([descs.NewFar(1, 1234)]))

Question (promise resulting from DeliverOp):

  ? def outgoingQuestion := remoteNonceLocator <- getTerminatedTestRef2()
  # value: <Promise>
  
  ?
  # stdout: ["Deliver", [-2, NewFarDesc(2, 1033912670282953026478972818820010722176128073325), 0, "getTerminatedTestRef2", []]]
  #         
  
Imported remote promise:

  ? def outgoingPromise := remoteNonceLocator <- getTerminatedTestRef3()
  # value: <Promise>

  ?
  # stdout: ["Deliver", [-3, NewFarDesc(3, 47255196895205160731987244561159478631887357377), 0, "getTerminatedTestRef3", []]]
  #         

  ? receiver.DeliverOnly(3, "run", buildIn([descs.NewRemotePromise(2, -1, 4352160789)]))

Export, which should receive a __reactToLostClient:

  ? E.sendOnly(remoteNonceLocator, "TerminatedExportTest", [
  >   def ttReactReceiver {to __reactToLostClient(p) { print(`rTLC expecter got $p`) }}])
  ?
  # stdout: ["DeliverOnly", [0, "TerminatedExportTest", [NewFarDesc(4, 412897248500657771667886264468852369692723684603)]]]
  #         

The termination:

  ? receiver.Terminated(buildIn("foo" :Throwable))
  # stdout: rTLC expecter got problem: foo

Consequences:

  ? [outgoingFar, outgoingQuestion, outgoingPromise, remoteNonceLocator]
  # value: [<ref broken by problem: foo>, <ref broken by problem: foo>, <ref broken by problem: foo>, <ref broken by problem: foo>]
  
  ? Ref.optProblem(outgoingFar) == Ref.optProblem(outgoingQuestion)
  # value: true

  ? Ref.optProblem(outgoingFar) == Ref.optProblem(outgoingPromise)
  # value: true

Checking for robust termination:

We don't need to test anything but the receiver, builder-maker, and builders, because every other access is an eventual ref that gets broken, as tested above.

  ? receiver.DeliverOnly(0, "", buildIn([]))
  # problem: this CapTP connection has been terminated (problem: foo)

  ? receiver.Deliver(-1, buildIn(null), 0, "", buildIn([]))
  # problem: this CapTP connection has been terminated (problem: foo)

  ? receiver.GCAnswer(-1)
  # problem: this CapTP connection has been terminated (problem: foo)

  ? receiver.GCExport(1, 0)
  # problem: this CapTP connection has been terminated (problem: foo)

  x ? receiver.Shutdown(0)
  x # problem: this CapTP connection has been terminated (problem: foo)

  ? receiver.Terminated(buildIn("bar"))
  # problem: this CapTP connection has been terminated (problem: foo)

  x ? receiver.Wormhole(-1, buildIn(null), 0, "", buildIn([]))
  x # problem: this CapTP connection has been terminated (problem: foo)

  ? buildIn(descs.Incoming(0))
  # problem: this CapTP connection has been terminated (problem: foo)

XXX test these things' behavior after termination:
  operations on builders gotten from the maker before the termination
  proxy finalizer
  locally referenced redirector (gets exported then sent home)

--- Incoming WormholeOp ---

XXX we don't have VatID processing yet

------ Incoming descriptors ------

--- Incoming NewFarDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? receiver.DeliverOnly(0, "__whenMoreResolved", buildIn([descs.NewFar(1, 13904808385)]))
  ?
  # stdout: ["DeliverOnly", [1, "run", [ImportDesc(0)]]]
  #         

--- Incoming NewRemotePromiseDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

First we set up an incoming reference to an object to catch the remote promise.

  ? clearFinalizers()
  > def remotePromise
  > def promiseReceiver(p) {
  >   println(`got $p`)
  >   bind remotePromise := p
  > }
  > def swiss :int := swissTable.getNewSwiss(promiseReceiver); null
  > receiver.Deliver(-3, buildIn(descs.NewFar(2, 928)), 0, "lookupSwiss", buildIn([swiss, null]))
  > receiver.GCAnswer(-3)
  ?
  # stdout: ["DeliverOnly", [2, "run", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

Then we deliver a message containing the promise.

  ? receiver.DeliverOnly(1, "run", buildIn([descs.NewRemotePromise(3, -4, def remotePromiseRdrBase := 4290823709)]))
  > receiver.GCExport(1, 1)
  # stdout: got <Promise>
  #         

Testing sends to the promise:

  ? E.sendOnly(remotePromise, "hello eventual", [])
  ?
  # stdout: ["DeliverOnly", [3, "hello eventual", []]]
  #         

Testing that the promise is present in the imports table:

  ? receiver.DeliverOnly(0, "__whenMoreResolved", buildIn([descs.Import(3)]))
  ?
  # stdout: ["DeliverOnly", [3, "run", [ImportDesc(0)]]]
  #         

The redirector should be accessible by our provided SwissBase:

  ? receiver.Deliver(-3, buildIn(descs.Import(2)), 0, "lookupSwiss", buildIn([remotePromiseRdrBase.cryptoHash(), null]))
  ?
  # stdout: ["DeliverOnly", [2, "run", [NewFarDesc(1, 216307466466887903142951307717254789854244528344)]]]
  #         

(remotePromiseRdrBase.cryptoHash().cryptoHash() == 216307466466887903142951307717254789854244528344)

Invoking the redirector causes the remote promise to resolve:

  ? receiver.DeliverOnly(-4, "run", buildIn([56]))
  ? remotePromise
  # value: 56
  
The remote promise proxy is now garbage, so CapTP should send GCExportOp:

  ? runFinalizers()
  ?
  # stdout: ["GCExport", [3, 2]]
  #         ["GCExport", [2, 2]]
  #         

Index 3 is the remote promise (passed in once as NewRemotePromiseDesc and once as ImportDesc), and index 2 is the twice-used fake redirector for incoming deliveries.

Export index 2 now holds the redirector.

Cleaning up:

  ? receiver.GCExport(1, 1) # the redirector retrieved by lookupSwiss
  > receiver.GCAnswer(-3) # the answer index of the lookupSwiss response
  > receiver.GCAnswer(-4) # the answer index of the redirector 

  XXX further tests

--- Incoming ImportDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

Setting up a proxy for testing:

  ? def swiss :int := swissTable.getNewSwiss(def _ {
  >   to compare(x, y) { println(x == y) }
  >   to compareNL(x) { println(x == remoteNonceLocator) }
  > }); null
  > receiver.Deliver(-1, buildIn(descs.NewFar(1, 2384978932)), 0, "lookupSwiss", buildIn([swiss, null]))
  > receiver.GCAnswer(-1)
  ? 
  # stdout: ["DeliverOnly", [1, "run", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

Actual testing:

  ? receiver.DeliverOnly(1, "compare", buildIn([descs.NewFar(1, 13904808385), 
  >                                             descs.Import(1)]))
  # stdout: true
  #         

  ? buildIn(descs.Import(999))
  # problem: 999 not alloced in ProxiesTable__1

  ? receiver.DeliverOnly(1, "compareNL", buildIn([descs.Import(0)]))
  # stdout: true
  #         

An ImportDesc cannot have a negative index (receiver's questions table) because that would conflict with the receiver being able to GC its questions table entries.

--- Incoming IncomingDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? def swiss :int := swissTable.getNewSwiss(def f(x) { println(x == f) }); null

  ? receiver.Deliver(-1, buildIn(descs.Incoming(0)), 0, "lookupSwiss", buildIn([swiss, null]))

  ? receiver.DeliverOnly(-1, "run", buildIn([descs.Incoming(-1)]) )
  # stdout: true
  #         

--- Incoming Promise3Desc ---

XXX

--- Incoming Far3Desc ---

XXX

------ Outgoing operations ------

--- Outgoing DeliverOnlyOp ---
XXX write this

--- Outgoing DeliverOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? def outgoingFar := remoteNonceLocator <- lookupSwiss(12345, null)
  # value: <Promise>
  ?
  # stdout: ["Deliver", [-1, NewFarDesc(1, 382064925828890872342377433413917253333972024416), 0, "lookupSwiss", [12345, null]]]
  #         

The above is a delivery to the NonceLocator, which is a bit of an unusual case; so we will also test a Far ref.

The remote side invokes the redirector for 'r', resolving it to a Far ref with import index 1.

  ? receiver.DeliverOnly(1, "run", buildIn([descs.NewFar(1, 2398478938902)]))
  ? outgoingFar
  # value: <Far ref>

Here's a normal message to that Far ref.

  ? outgoingFar <- foo()
  # value: <Promise>
  ? 
  # stdout: ["Deliver", [-2, NewFarDesc(2, 1033912670282953026478972818820010722176128073325), 1, "foo", []]]
  #         


--- Outgoing GCExportOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

GCExportOp is sent when a proxy for an import-table entry has gone away; so to test it, we simulate an arriving import which is discarded.

  ? clearFinalizers()
  > receiver.DeliverOnly(0, "__optSealedDispatch", buildIn([descs.NewFar(2, 38249328)]))
  ? runFinalizers()
  ?
  # stdout: ["GCExport", [2, 1]]
  #         

Note that the sender of GCExportOp does not know whether the index was actually freed by the remote side; if it was, the index will be overwritten by a New*Desc; otherwise, an ImportDesc will arrive causing the creation of a new proxy for the existing table entry.

  ? clearFinalizers()
  > receiver.DeliverOnly(0, "__optSealedDispatch", buildIn([descs.NewFar(2, 38249328)]))
  > receiver.DeliverOnly(0, "__optSealedDispatch", buildIn([descs.Import(2)]))
  ? runFinalizers()
  ?
  # stdout: ["GCExport", [2, 2]]
  #         


--- Outgoing GCAnswerOp ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

We create a remote promise for an answer and tell the connection that it has been GCed.

  ? clearFinalizers()
  > E.send(remoteNonceLocator, "lookupSwiss", [93478934, null])
  > null
  ?
  # stdout: ["Deliver", [-1, NewFarDesc(1, 382064925828890872342377433413917253333972024416), 0, "lookupSwiss", [93478934, null]]]
  #         
  
  ? runFinalizers()
  ?
  # stdout: ["GCAnswer", [-1]]
  #

After GC, the question table entry is free and will be reused.

  ? E.send(remoteNonceLocator, "lookupSwiss", [23948931413532, null])
  > null
  ?
  # stdout: ["Deliver", [-1, NewFarDesc(2, 1033912670282953026478972818820010722176128073325), 0, "lookupSwiss", [23948931413532, null]]]
  #         
  
  ? runFinalizers()
  ?
  # stdout: ["GCAnswer", [-1]]
  #


--- Outgoing ShutdownOp ---
XXX write this
--- Outgoing TerminatedOp ---
XXX write this
--- Outgoing WormholeOp ---
XXX write this

------ Outgoing descriptors ------

--- Outgoing NewFarDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? E.sendOnly(remoteNonceLocator, "newFarDescTest", [def newSelfish {}])
  ?
  # stdout: ["DeliverOnly", [0, "newFarDescTest", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

After an outgoing NewFarDesc, the object should be present in the exports table, so further outgoing messages use ImportDesc:

  ? E.sendOnly(remoteNonceLocator, "sameFarTest", [newSelfish])
  ?
  # stdout: ["DeliverOnly", [0, "sameFarTest", [ImportDesc(1)]]]
  #         

--- Outgoing NewRemotePromiseDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? def exportedPromise
  > E.sendOnly(remoteNonceLocator, "newRemotePromiseDescTest", [exportedPromise])
  ?
  # stdout: ["DeliverOnly", [0, "newRemotePromiseDescTest", [NewRemotePromiseDesc(1, -1, 10000001)]]]
  #         
  
  ? bind exportedPromise := 31432943; null
  ?
  # stdout: ["DeliverOnly", [-1, "run", [31432943]]]
  #         

(Yes, it is correct that the third argument isn't a hash. It's direct from entropy.nextSwiss(), and is a SwissBase, the authority to *be* an object (as seen from outside some vat).)

XXX test properties of the identity of the redirector passed to exportedPromise <- __whenMoreResolved, and that if re-imported it is still good

XXX test that index 1 delivers to the promise

--- Outgoing ImportDesc ---

See NewFarDesc above for testing of ordinary imports; this is the special NonceLocator case.

  XXX write this test

--- Outgoing IncomingDesc ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

IncomingDesc for the nonce locator (magic index 0)

  ? E.sendOnly(remoteNonceLocator, "incomingNonceLocatorTest", [remoteNonceLocator])
  ?
  # stdout: ["DeliverOnly", [0, "incomingNonceLocatorTest", [IncomingDesc(0)]]]
  #         

IncomingDesc for an export

  ? def outgoing := remoteNonceLocator <- willBeFar(); null
  ?
  # stdout: ["Deliver", [-1, NewFarDesc(1, 382064925828890872342377433413917253333972024416), 0, "willBeFar", []]]
  #         
  ? receiver.DeliverOnly(1, "run", buildIn([descs.NewFar(1, 398427908325834)]))

  ? E.sendOnly(remoteNonceLocator, "incomingFarTest", [outgoing])
  ?
  # stdout: ["DeliverOnly", [0, "incomingFarTest", [IncomingDesc(1)]]]
  #         

IncomingDesc for an answer

  ? def outgoing := remoteNonceLocator <- willBePromise(); null
  ?
  # stdout: ["Deliver", [-2, NewFarDesc(2, 1033912670282953026478972818820010722176128073325), 0, "willBePromise", []]]
  #         

  ? E.sendOnly(remoteNonceLocator, "incomingAnswerTest", [outgoing])
  ?
  # stdout: ["DeliverOnly", [0, "incomingAnswerTest", [IncomingDesc(-2)]]]
  #         

--- Outgoing Promise3Desc ---
XXX
--- Outgoing Far3Desc ---
XXX

------ Serialization ------

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? E.sendOnly(remoteNonceLocator, "setupIncoming", [println])
  ?
  # stdout: ["DeliverOnly", [0, "setupIncoming", [NewFarDesc(1, 382064925828890872342377433413917253333972024416)]]]
  #         

--- Disconnected ref ---

  ? E.sendOnly(remoteNonceLocator, "s", [Ref.broken("b")])
  ?
  # stdout: ["DeliverOnly", [0, "s", [<ref broken by problem: b>]]]
  #         

  ? receiver.DeliverOnly(1, "run", buildIn([Ref.broken("b")]))
  # stdout: <ref broken by problem: b>
  #         

--- LocatorUnum ---

  ? E.sendOnly(remoteNonceLocator, "s", [locatorUnumLocal])
  ?
  # stdout: ["DeliverOnly", [0, "s", [<locatorUnumRemote>]]]
  #         

  ? receiver.DeliverOnly(1, "run", buildIn([locatorUnumRemote]))
  # stdout: <locatorUnumLocal>
  #         


XXX write more serialization tests

------ Other ------

--- remoteNonceLocator ref ---

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? E.sendOnly(remoteNonceLocator, "foo", [])
  ?
  # stdout: ["DeliverOnly", [0, "foo", []]]
  #         

--- Misinterleaved unserialization ---

This is prohibited because it can cause subtle failures due to descriptors such as IncomingDesc being unserialized before the messages that define their indexes arrive.

  ? def [swissTable, receiver, remoteNonceLocator, buildIn] := makeTestConnection()
  # value: [<swissTable>, <capTPReceiver>, <Far ref>, <buildIn>]

  ? def b1 := buildIn([])
  > def b2 := buildIn([])
  > null
  
  ? receiver.DeliverOnly(0, "__getAllegedType", b1)
  > receiver.DeliverOnly(0, "__getAllegedType", b2)
  # problem: CapTP incoming message #1 was given an argument unserialized during time for message #0