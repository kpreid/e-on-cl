# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

--- Setup

  ? def <qu> := <import:org.quasiliteral.*>; null
  ? def makeTermBuilder := <qu:term.makeTermBuilder>; null
  ? def termBuilder := makeTermBuilder(); null
  ? def makeQBuilder := <qu:quasiterm.makeQBuilder>; null
  ? def qb := makeQBuilder(termBuilder)
  # value: <qBuilder>

--- Terms
XXX write these tests, in independent-of-TermParser form

  ? def qt := qb.start(qb.term(qb.tag([["Ident", "foo"]])))
  # value: qterm`foo`
  
  ? qt.substitute([])
  # value: term`foo`

  ? def qet := qb.start(qb.term(qt, qb.empty()))
  # value: qterm`foo()`

  ? def qat := qb.start(qb.term(qt, qt))
  # value: qterm`foo(foo)`
  
  ? qat.substitute([])
  # value: term`foo(foo)`

--- Special terms

  ? def qtBag := qb.start(qb.bag(qt))
  # value: qterm`.bag.(foo)`
  XXX print should probably be {foo}

  ? def qtTuple := qb.start(qb.tuple(qt))
  # value: qterm`.tuple.(foo)`
  XXX print should probably be [foo]

--- Literals

  ? def dqt := qb.start(qb.leafData(def d := "foo", null))
  # value: qterm`"foo"`

  ? def dt := dqt.substitute([])
  # value: term`"foo"`
  
  ? [dt.getData(), dt.getData() == d]
  # value: ["foo", true]

--- Holes

  ? def hqt := qb.start(qb.valueHole(0))
  # value: qterm`${0}`
  
  ? hqt.substitute([term`foo`])
  # value: term`foo`
