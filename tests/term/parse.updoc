# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

--- Setup

  ? def <qu> := <import:org.quasiliteral.*>; null
  ? def makeTermBuilder := <qu:term.makeTermBuilder>; null
  ? def termBuilder := makeTermBuilder(); null
  ? def makeTermLexer := <qu:term.makeTermLexer>; null

---

  ? def makeTermParser := <qu:term.makeTermParser>; null

  ? def makeLexStream() :any { makeTermLexer(false)("foo".asStream()) }; null
  
  ? def genericBuilder { 
  >   to doesQuasis() :any { true }
  >   match [v, a] { [v] + a } }; null

  ? makeTermParser(genericBuilder).parse(makeLexStream())
  # value: ["start", ["term", ["tag", [["Ident", "foo"]]]]]

  ? makeTermParser(genericBuilder).parseText("foo".asStream())
  # value: ["start", ["term", ["tag", [["Ident", "foo"]]]]]

--- Grammar

  ? def p(tokens) :any { makeTermParser(genericBuilder).parse(tokens.asStream()) }; null

foo(foo)

  ? p([["Tag", [["Ident", "foo"]]], ["("], ["Tag", [["Ident", "foo"]]], [")"]])
  # value: ["start", ["term", ["tag", [["Ident", "foo"]]], ["term", ["tag", [["Ident", "foo"]]]]]]

foo(bar, baz)

  ? p([["Tag", [["Ident", "foo"]]], ["("], ["Tag", [["Ident", "bar"]]], [","], ["Tag", [["Ident", "baz"]]], [")"]])
  # value: ["start", ["term", ["tag", [["Ident", "foo"]]], ["seq", ["term", ["tag", [["Ident", "bar"]]]], ["term", ["tag", [["Ident", "baz"]]]]]]]

[foo]

  ? p([["["], ["Tag", [["Ident", "foo"]]], ["]"]])
  # value: ["start", ["tuple", ["term", ["tag", [["Ident", "foo"]]]]]]

{foo}

  ? p([["{"], ["Tag", [["Ident", "foo"]]], ["}"]])
  # value: ["start", ["bag", ["term", ["tag", [["Ident", "foo"]]]]]]

foo{bar}

  ? p([["Tag", [["Ident", "foo"]]], ["{"], ["Tag", [["Ident", "bar"]]], ["}"]])
  # value: ["start", ["term", ["tag", [["Ident", "foo"]]], ["bag", ["term", ["tag", [["Ident", "bar"]]]]]]]

foo:bar

  ? p([["Tag", [["Ident", "foo"]]], [":"], ["Tag", [["Ident", "bar"]]]])
  # value: ["start", ["attr", ["tag", [["Ident", "foo"]]], ["term", ["tag", [["Ident", "bar"]]]]]]

Literals

  ? p([["Integer", 1]])
  # value: ["start", ["term", ["leafInteger", 1]]]
  ? p([["Float64", 1.0]])
  # value: ["start", ["term", ["leafFloat64", 1.0]]]
  ? p([["Char", 'a']])
  # value: ["start", ["term", ["leafChar", 'a']]]
  ? p([["String", "a"]])
  # value: ["start", ["term", ["leafTwine", "a"]]]

--- Quasi and parsing

  ? def makeQBuilder := <qu:quasiterm.makeQBuilder>; null

  ? def qBuilder := makeQBuilder(termBuilder)
  # value: <qBuilder>
 
  ? makeTermParser(qBuilder).parse(makeLexStream())
  # value: qterm`foo`

  ? makeTermParser(qBuilder).parseText("foo".asStream())
  # value: qterm`foo`

XXX all term-language grammar

  ? qBuilder.valueMaker("foo").substitute([])
  # value: term`foo`

XXX substitution on all term trees

  ? term`foo`
  # value: term`foo`

XXX more tests...