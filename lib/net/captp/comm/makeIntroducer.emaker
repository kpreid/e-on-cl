# Copyright 2007 Kevin Reid under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("call-pattern")

def scheme := "captp"

def makeSwissTable := <import:net.captp.tables.makeSwissTable>
def asWaterkenBase32 := <import:net.captp.util.asWaterkenBase32>
def now := <import:org.cubik.cle.schedule.now>
def unsignedIntegerCoding := <import:org.cubik.cle.binary.unsignedIntegerCoding>

def makeIntroducer implements ExitViaHere, DeepFrozen {
  to makePair(config :Map,
              entropy :any, # XXX interface
              timer :any) { # XXX interface
    
    interface SturdyRef {} # XXX stub
    
    def swissTable := makeSwissTable(entropy, <elib:tables.makeFlexMap>, <elib:tables.makeFlexMap>) # XXX should be weak-key and weak-value maps
    
    def negotiable := ["BOGUS_PLACEHOLDER"]
    
    var onTheAir := false
    
    def srMap := [].asMap().diverge() # XXX either make sturdyrefs selfless and remove this table, or make it weak
    def getSturdyRef(vatIDStr, searchPathStr, swissNumber) {
      def key := [vatIDStr, searchPathStr, swissNumber]
      if (srMap.maps(key)) { return srMap[key] }
      def sturdyRef implements SturdyRef {
        to __printOn(out :TextWriter) {
          if (vatIDStr == "foo") {
            out.write("<sturdyRef to ")
            out.quote(sturdyRef.getRcvr())
            out.write(">")
          } else {
            out.write("<sturdyRef>")
          }
        }
        to getRcvr() {
          if (onTheAir) {
            if (vatIDStr == "foo") {
              return swissTable.lookupSwiss(swissNumber)
            } else {
              throw("remote sturdyref unimplemented")
            }
          } else {
            throw("introducer not yet identified")
          }
        }
        to _uriBody() { # XXX should be opaque
          return `//*$vatIDStr@@$searchPathStr/${asWaterkenBase32(swissNumber.toOctetsUnsigned())}`
        }
      }
      srMap[key] := sturdyRef
      return sturdyRef
    }
    
    def locatorUnum {} # XXX stub
    
    def introducer {
      to getLocatorUnum() { return locatorUnum }
      to getNetConfig() { throw("XXX no net config object yet") } # XXX stub
      to getVatID() { throw("introducer not yet identified") } # XXX stub
      to hasIdentity() { return false } # XXX stub
      to isOnTheAir() { return false } # XXX stub
      to negotiable() { return negotiable } # XXX stub
      
      to onTheAir() {
        onTheAir := true
        return negotiable
      }
      
      to __printOn(out :TextWriter) {
        if (onTheAir) {
          out.write(`<On the Air $negotiable>`)
        } else {
          out.write("<Off the Air>")
        }
      }
    }
    
    def identityMgr {
       to __printOn(out :TextWriter) {
         out.write("<identityMgr Off the Air>")  # XXX stub
       }
       
       to makeKnown(ref) {
         if (onTheAir) {
           def swissBase := entropy.nextSwiss()
           def swissNumber := swissTable.registerNewSwiss(ref, swissBase)
           def sr := getSturdyRef("foo", "", swissNumber) # XXX non-stub vatid+searchpath
           return [sr, def timeout {}, swissBase]
         } else {
           throw(`<SecurityException: introducer not yet identified>`) # XXX wording
         }
       }
       
       # XXX other ops
    }
    
    def <captp> {
      to get(uriBody :String) {
        def `//*@vatIDStr@@@searchPathStr/@{asWaterkenBase32(swissNumberBytes ? (swissNumberBytes != []))}` \
          exit fn p { throw(`Malformed CapTP URI: ${if (`$p` =~ `problem: @t`) {t} else {p}}`) } \
          := uriBody
        # XXX silly way to turn bytes into int; should be __makeInt.fromDigits(1, swissNumberBytes, 256) once that is implemented
        def swissNumber := unsignedIntegerCoding[swissNumberBytes.size() * 8].takingFrom(swissNumberBytes.asStream(), now)()
        return getSturdyRef(vatIDStr, searchPathStr, swissNumber)
      }
      to sturdyFromURI(uri :String) {
        # XXX unnecessary printing
        # XXX deleting 'problem: ' ought to be done by printing without it
        def `$scheme:@uriBody` \
          exit fn p { throw(`Malformed CapTP URI: ${if (`$p` =~ `problem: @t`) {t} else {p}}`) } \
          := uri
        return <captp>[uriBody]
      }
      
      to sturdyToURI(sr) { # XXX guard
        return `$scheme:${sr._uriBody()}`
      }
      to optUnget(specimen) {
        if (specimen =~ sr :SturdyRef) {
          return sr._uriBody()
        }
      }
      to optUncall(specimen) {
        if (specimen =~ sr :SturdyRef) {
          return [introducer, "get", sr._uriBody()]
        }
      }
    }
    
    return [introducer, identityMgr, <captp>]
  }
}