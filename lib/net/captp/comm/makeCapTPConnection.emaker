# Copyright 2007 Kevin Reid under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("function-implements")
pragma.enable("accumulator")

def map implements DeepFrozen {
  to v(f, coll) {
    return accum [] for v in coll {_.with(f(v))}}
  to kv(f, coll) {
    return accum [] for k => v in coll {_.with(f(k, v))}}
}

# definitions per http://www.erights.org/elib/distrib/captp/types.html
def IncomingPos := -2**31..!2**31
def ExportPos := 1..!2**31
def AnswerPos := -2**31..-1
def ImportPos := 0..!2**31
def WireDelta := 0..255
def MsgCount := 0..!2**63
def MsgName := String
def VatID := String
def SwissBase := int
def SwissNumber := int
def SwissHash := int
def Nonce := int
def OneArgFunc := <elib:util.OneArgFunc>

def DESCS_EXIT := "CapTP_1_descs"

def makeProxy := <elib:ref.makeProxy>
def makeBrand := <elib:sealing.makeBrand>

def makeNonceLocator := <import:net.captp.comm.makeNonceLocator>
def makeAnswersTable := <import:net.captp.tables.makeAnswersTable>
def makeExportsTable := <import:net.captp.tables.makeExportsTable>
def makeProxiesTable := <import:net.captp.tables.makeProxiesTable>

def descMakerStandin implements DeepFrozen {}

def makeCapTPConnection implements ExitViaHere, DeepFrozen {
  to run(outgoingReceiver, outArgBuilderMaker, swissTable, whenGarbage) {
    def nonceLocator := makeNonceLocator(null,
                                         null,
                                         "fake-id-ctc",
                                         null,
                                         swissTable)
    
    def answers := makeAnswersTable()
    def exports := makeExportsTable()
    def imports := makeProxiesTable()
    def questions := makeProxiesTable()
    
    def [remoteIncomingPosSealer, remoteIncomingPosUnsealer] := 
      makeBrand("CapTP far ref's remote incomingPos")
    def remoteIncomingPosBrand := remoteIncomingPosSealer.getBrand()

    def deSubgraphKit := <elib:serial.deSubgraphKit> # XXX unnecessarily not DeepFrozen
    def makeCycleBreaker := <elib:tables.makeCycleBreaker> # ditto
    def once := <import:org.erights.e.facet.once> # ditto
    
    def unscope := {
      def u := deSubgraphKit.getDefaultUnscope().diverge()
      u[descMakerStandin] := DESCS_EXIT
      u.snapshot()
    }
    
    /** Uncalls our local NonceLocator being passed out. */
    def nonceLocatorUncaller {
      to optUncall(ref) {
        if (__equalizer.sameYet(ref, nonceLocator)) {
          return [descMakerStandin, "Import", [0]]
        }
      }
    }
    
    def pbcUncaller {
      to optUncall(r) {
        if (r =~ p :pbc && r == p) {
          return p.__optUncall()
        }
      }
    }
    
    /** Uncalls Far refs that are being passed to their home vat. */
    def goingHomeUncaller {
      to optUncall(ref) {
        if (remoteIncomingPosUnsealer.amplify(ref) =~ [pos :IncomingPos]) {
          return [descMakerStandin, "Incoming", [pos]]
        }
      }
    }
    
    def proxyUncaller {
      to optUncall(r) {
        if (Ref.isSelfish(r)) {
          if ((def index := exports.indexFor(r)) != -1) {
            exports.incr(index)
            return [descMakerStandin, "Import", [index]]
          } else {
            def swissNumber := swissTable.getNewSwiss(r)
            return [descMakerStandin, "NewFar", [exports.newFarPos(r), swissNumber.cryptoHash()]]
          }
        }
      }
    }
    
    # XXX document exit table used
    def encRecognizer := deSubgraphKit.makeRecognizer(
      [goingHomeUncaller,
       nonceLocatorUncaller,
       pbcUncaller,
       proxyUncaller],
      unscope)
    
    /** given an index from an incoming message, look up the corresponding local object */
    def lookupIncoming(index :int) {
      return if (index.isZero()) {
        nonceLocator
      } else if (index.belowZero()) {
        answers[-index]
      } else { # above zero
        exports[index]
      }
    }

    def lookupImport(index :int) {
      return if (index.isZero()) {
        throw("Not proven necessary yet")
        #return remoteNonceLocator
      } else if (index.belowZero()) {
        #questions[-index]
        throw("can't happen: <0 import")
      } else { # above zero
        imports.getProxy(index)
      }
    }

    /** Transform a CapTP message argument object into an outgoing wire message. */
    def outEncode(object) {
      return encRecognizer.recognize(object, outArgBuilderMaker())
    }
    
    def capTPReceiver {
      to DeliverOnly(recipPos :IncomingPos,
                     verb :MsgName,
                     args :List[any]) :void {
        E.sendOnly(lookupIncoming(recipPos), verb, args)
      }

      to Deliver(answerPos :AnswerPos,
                 rdr :OneArgFunc,
                 recipPos :IncomingPos,
                 verb :MsgName,
                 args :List[any]) :void {
        def answer := E.send(lookupIncoming(recipPos), verb, args)
        answers.put(-answerPos, answer, true)
        E.sendOnly(answer, "__whenMoreResolved", [rdr])
      }
      
      to GCAnswer(answerPos :AnswerPos) {
        answers.free(-answerPos)
      }
    }
    
    def makeEventualHandler(position :vow[IncomingPos]) {
      return def capTPEventualHandler {
        to handleSend(verb, args) {

          def [proxyResolutionSlot, proxySlotResolver] := Ref.promise()

          def redirector(resolution) :void {
            #traceln(`Redirector for $position $verb $args got resolution $resolution`)
            proxySlotResolver.resolveRace(&resolution)
          }

          def questionPos := questions."bind"([makeEventualHandler(questionPos <- negate()), proxyResolutionSlot, proxySlotResolver, false])

          E.sendOnly(outgoingReceiver, "Deliver", [-questionPos, outEncode(redirector), position, verb, outEncode(args)])
          
          # XXX this smells funny: if something else does questions.getProxy, the index could be GC'd too early by *this* finalizer. There's nothing that does that yet, though. Should we be using the table's allocation counter?
          def proxy := questions.getProxy(questionPos)
          whenGarbage(proxy, once(fn {
            #traceln(`GCAnswer finalizer invoked for -$questionPos`)
            E.sendOnly(outgoingReceiver, "GCAnswer", [-questionPos])
            questions.free(questionPos)
          }))
          
          return proxy
        }
        to handleSendOnly(verb, args) {
          E.sendOnly(outgoingReceiver, "DeliverOnly", [position, verb, outEncode(args)])
        }
        to handleOptSealedDispatch(brand) {
          if (brand == remoteIncomingPosBrand) {
            return remoteIncomingPosSealer.seal(position)
          }
        }
        
        to __printOn(out :TextWriter) {
          out.print("<CapTP proxy handler for ", position, " of ", outgoingReceiver, ">")
        }
      }
    }
    
    def incomingDescMaker {
      to NewFar(importPos :ImportPos,
                   swissHash :SwissHash) {
        # XXX reuse proxies for same swissHash
        def [resolutionSlot, proxySlotResolver] := Ref.promise()
        imports.put(importPos, [makeEventualHandler(importPos), resolutionSlot, proxySlotResolver, true])
        return imports.getProxy(importPos)
      }
      
      to Import(importPos :ImportPos) {
        return lookupImport(importPos)
      }
  
      to Incoming(incomingPos :IncomingPos) {
        return lookupIncoming(incomingPos)
      }
    }
    
    def buildScope := deSubgraphKit.getDefaultScope().with(DESCS_EXIT, incomingDescMaker)
    
    def capTPBuilderMaker() {
      return deSubgraphKit.makeBuilder(buildScope)
    }
    
    # The remote nonce locator is a Far reference which is unique to this connection -- XXX this representation will have to be changed for ShutdownOp; see connection.updoc
    def remoteNonceLocator := makeProxy(makeEventualHandler(0), Ref.promise()[0], true)

    return [capTPReceiver, capTPBuilderMaker, remoteNonceLocator]
  }
}