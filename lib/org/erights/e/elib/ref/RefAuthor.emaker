# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.disable("easy-return")
pragma.disable("explicit-result-guard")

pragma.enable("function-implements")

def Throwable := <import:org.cubik.cle.prim.Throwable>
def makeException := <import:org.cubik.cle.prim.makeException>

def RefAuthor {
  # XXX map args?
  # Stamped rather than audited deep-frozen since DeepFrozen is nonprimitive and uses Ref itself in the course of auditing. XXX have DeepFrozenAuthor use primitives?
  to run(makePromise, refState, refIsResolved, makeUnconnectedRef, refOptProblem, sElibBroken, sElibNear, sElibEventual, DeepFrozenStamp) :any {

    def nbmPrinter(out :TextWriter, ex) implements DeepFrozenStamp {
      out.quote(ex.getSpecimen())
      out.write(" is not broken")
    }

    def Ref implements DeepFrozenStamp {
      to promise() :any { makePromise() }
      
      to isBroken(r)   :any { refState(r) == sElibBroken }
      to isNear(r)     :any { refState(r) == sElibNear }
      to isEventual(r) :any { refState(r) == sElibEventual }
      to isFar(r) :any { refState(r) == sElibEventual && refIsResolved(r) }
      
      to isSettled(r)  :any { __equalizer.isSettled(r) }
      to isResolved(r) :any { refIsResolved(r) }
      
      to broken(p) :any { 
        # The new exception-sealing system means that broken references must be able to hold arbitrary values. However, current E programs (and our test suite) expect Ref.broken("foo") to make an exception object. Thus this guard.
        makeUnconnectedRef(Throwable.coerce(p, throw))
      }
      to optProblem(r) :any { refOptProblem(r) }
      to "match__broken/1"(r, ej) :any {
        if (refState(r) == sElibBroken) {
          [refOptProblem(r)]
        } else {
          throw.eject(ej, makeException([meta.context().getFQNPrefix() + "NotBrokenMismatch"], ["specimen" => r], nbmPrinter))
        }
      }
      
      to isPassByCopy(r) :any { 
        if (__equalizer.isSelfless(r)) { Ref.isPBC(r) } else { false }
      }
      to isPBC(r) :any { 
        return (escape fail { pbc.coerce(r, fail) == r } catch _ { false })
      }
      to whenResolved(ref, reactor) :any {
        # XXX does this match the semantics of the standard E whenResolved?
        #traceln(`entering whenResolved`)
        def [resultPromise, resultResolver] := makePromise()
        def safeWhenResolvedReactor(_) :void {
          #traceln(`entering safeWhenResolvedReactor (ref is $ref)`)
          if (refIsResolved(ref)) {
            #traceln(`  is-resolved branch ($resultResolver)`)
            if (!resultResolver.isDone()) {
              #traceln(`  resolving reactor`)
              resultResolver.resolve(reactor <- run(ref))
            } else {
              #traceln(`  duplicate reactor invocation`)
            }
            #traceln(`  finished`)
          } else {
            #traceln(`  not-resolved branch`)
            ref <- __whenMoreResolved(safeWhenResolvedReactor)
            #traceln(`  sent next __whenMoreResolved to $ref`)
          }
        }
        safeWhenResolvedReactor(null)
        resultPromise
      }
      
      to fulfillment(r) :any {
        def p := refOptProblem(r)
        if (p != null) {
          throw(p)
        } else if (refIsResolved(r)) {
          r
        } else {
          throw("not resolved (Ref#fulfillment)")
        }
      }
    }
  }
}
