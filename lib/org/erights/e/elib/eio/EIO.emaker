# Copyright 2005-2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("accumulator")
pragma.enable("function-implements")

def makeTextWriter := <elib:oldeio.makeTextWriter>

def ALL := null # XXX should be something else
def Range := nullOk[int >= 0]

def whenMaybeNow(ref, reactor) implements DeepFrozen {
  return if (Ref.isResolved(ref)) {
    reactor(ref)
  } else {
    Ref.whenResolved(ref, reactor)
  }
}

def evSplit(n, l) {
  return accum [] for i in 0..!n { _.with(l <- get(i)) }
}

def EIO implements DeepFrozen, ExitViaHere {
  to getRange() { return Range }

  /** The value denoting all remaining elements in an EIO stream. */
  to getALL() { return ALL }
  
  /** Transfers the elements of an InStream to an OutStream. Acts immediately if possible; for non-immediate effects, use EIO <- join(...). The return value will be resolved, to the terminator of the input stream, as soon as no more elements will be delivered to the OutStream; at this time, the output stream will also be terminated. */
  to join(input, output) {
    return <import:org.cubik.cle.io.join>(input, output)
  }
  
  to pipe(options) {
    return <import:org.cubik.cle.io.makeSimplePipe>(options)
  }
  
  /** Take at least 'minimum' and at most 'maximum' elements from 'inStream' and return them.
    * 
    * 'minimum' may not be ALL unless 'maximum' is ALL; this is an implementation limitation. It would mean to read all elements and fail unless there are 'maximum' of them.
    * 
    * XXX stream redesign: to be reviewed */
  to takeRange(minimum :DeepFrozen, maximum :DeepFrozen, inStream) {
    #traceln(`entering takeRange $minimum, $maximum, $inStream`)
    
    
    
    if (maximum != ALL && (minimum == ALL || minimum > maximum)) {
      throw(`impossible range for EIO.takeRange, $minimum..$maximum, requested from $inStream`)
    }
    
    return whenMaybeNow(inStream.takeAtMost(0), fn first {
      #traceln(`got first chunk $first`)
      def [append, snapshot] := switch (first) {
        # XXX doesn't work for Twines 
        match =="" { def [tw, sb] := makeTextWriter.makeBufferingPair(); [tw.write, sb.snapshot] }
        match _ { def l := [].diverge(); [l.append, l.snapshot] }
      }
      
      def computeWanted := if (maximum == ALL) {
        fn { ALL }
      } else {
        fn { maximum - snapshot().size() }
      }
      def isSufficient := if (minimum == ALL) {
        fn { false }
      } else {
        fn { minimum <= snapshot().size() }
      }
      
      def result
      def loop() {
        #traceln(`takeRange loop`)
        while (!Ref.isResolved(result)) {
          #traceln(`takeRange subloop`)
          def taken := inStream.takeAtMost(computeWanted())
          def handle() {
            #traceln(`handle() for ${Ref.state(taken)} ${try{taken.__getAllegedType()} catch p {"NV"}}`)
            switch (taken) {
              match ==null {
                #if (minimum == ALL || minimum <= snapshot().size()) {
                  bind result := snapshot()
                #} else {
                #  bind result := Ref.broken(`insufficient elements: requested at least $minimum, got only ${snapshot().size()}`)
                #}
              }
              match b ? (Ref.isBroken(b)) { bind result := b }
              match chunk { 
                append(chunk)
                if (isSufficient()) {
                  #traceln(`exiting, got minimum`)
                  bind result := snapshot()
                  break
                }
              }
            }
          }
          if (!Ref.isResolved(taken)) {
            when (taken) -> {} finally {
              handle()
              loop()
            }
            return
          } else {
            handle()
          }
        }
      }
      loop()
      result
    })
  }
  
  /** XXX stream redesign: to be reviewed */
  to takeAll(inStream) {
    return EIO.takeRange(ALL, ALL, inStream)
  }
}