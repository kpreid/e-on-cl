# Copyright 2005-2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("accumulator")
pragma.enable("function-implements")

def makeTextWriter := <elib:oldeio.makeTextWriter>

def ALL := null # XXX should be something else
def Range := nullOk[int >= 0]

def whenMaybeNow(ref, reactor) implements DeepFrozen {
  return if (Ref.isResolved(ref)) {
    reactor(ref)
  } else {
    Ref.whenResolved(ref, reactor)
  }
}

def evSplit(n, l) {
  return accum [] for i in 0..!n { _.with(l <- get(i)) }
}

def EIO implements DeepFrozen, ExitViaHere {
  to getRange() { return Range }

  /** The value denoting all remaining elements in an EIO stream. */
  to getALL() { return ALL }
  
  /** Transfers the elements of an InStream to an OutStream. Acts immediately if possible; for non-immediate effects, use EIO <- join(...). The return value will be resolved, to the terminator of the input stream, as soon as no more elements will be delivered to the OutStream; at this time, the output stream will also be terminated. */
  to join(input, output) {
    return <import:org.cubik.cle.io.join>(input, output)
  }
  
  to pipe(options) {
    return <import:org.cubik.cle.io.makeSimplePipe>(options)
  }
  
  /** XXX stream redesign: to be reviewed */
  to takeAll(inStream) {
    traceln(`entering takeAll $inStream`)
    return whenMaybeNow(inStream.takeAtMost(0), fn first {
      traceln(`got first chunk $first`)
      def [append, snapshot] := switch (first) {
        # XXX doesn't work for Twines 
        match =="" { def [tw, sb] := makeTextWriter.makeBufferingPair(); [tw.write, sb.snapshot] }
        match _ { def l := [].diverge(); [l.append, l.snapshot] }
      }
      def result
      def loop() {
        traceln(`takeAll loop`)
        while (!Ref.isResolved(result)) {
          def taken := inStream.takeAtMost(ALL)
          def handle() {
            switch (taken) {
              match ==null { bind result := snapshot() }
              match b ? (Ref.isBroken(b)) { bind result := b }
              match chunk { append(chunk) }
            }
          }
          if (!Ref.isResolved(taken)) {
            when (taken) -> { 
              handle()
              loop()
            }
            return
          } else {
            handle()
          }
        }
      }
      loop()
      result
    })
  }
}