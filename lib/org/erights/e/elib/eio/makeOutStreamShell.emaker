# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("dot-props")

def Range := EIO::Range
def ALL := EIO::ALL

def makeStreamShell := <elib:eio.makeStreamShell>

def makeOutStreamShell implements DeepFrozen {
  to run(Element, backend__Resolver, impl) {

    def terminator
  
    def [streamShell, &available, triggerAvailable] := \
      makeStreamShell(Element,
                      thunk {impl.terminate(terminator)},
                      if (impl.__respondsTo("wants", 1)) {impl.wants} \
                                                    else {def stubWants(_) {}})
    
    bind terminator := streamShell.terminates()
    
    def outStream extends streamShell { # implements OutStream
      to __printOn(out :TextWriter) :void {
        out.write("->")
        out.printSame(impl)
      }
      
      to write(elements :List) {
        if (Ref.isResolved(terminator)) {
          if (terminator == true) {
            throw("<UnavailableException: stream closed>")
          } else {
            throw(Ref.optProblem(terminator))
          }
        
        } else {
          if (available != ALL) {
            def size := elements.size()
            if (available < size) {
              # XXX explicit type
              throw(`<UnavailableException: $size elements cannot be written at this time (only $available)>`)
            }
            available -= size
          }
          impl.write(elements)
        }
      }
      
      to flush() {
        if (!Ref.isResolved(terminator)) {
          impl.flush()
        }
      }
      
      # XXX should have write() with ejector(s) for failure types
    }
    
    bind backend {
      /** May synchronously call the client's whenAvailable reactor. */
      to setAvailable(new) {
        available := new
        triggerAvailable()
      }
    }
    
    return outStream
  }
}



