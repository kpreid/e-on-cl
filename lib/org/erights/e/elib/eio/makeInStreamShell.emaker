# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("dot-props")

def Range := EIO::Range
def ALL := EIO::ALL

def NOW := EIO::NOW
def LATER := EIO::LATER 
def WAIT := EIO::WAIT
def ADVANCE := EIO::ADVANCE
def QUERY := EIO::QUERY
def ELEMENTS := EIO::ELEMENTS
def STATUS := EIO::STATUS

def Same {
  match [=="get", values] {
    def valuesSet := values.asSet()
    def message := "must be one of " + E.toQuote(values) + ": "
    def Same1 {
      to coerce(specimen, optEjector) {
        if (valuesSet.contains(specimen)) {
          return specimen
        } else {
          throw.eject(optEjector, message + E.toQuote(specimen))
        }
      }
    }
  }
}

def Schedule := Same[NOW, LATER, WAIT]
def Proceed  := Same[ADVANCE, QUERY]
def Report   := Same[ELEMENTS, STATUS]

def makeStreamShell := <elib:eio.makeStreamShell>

def makeInStreamShell implements DeepFrozen {
  to run(Element, backend__Resolver, impl) {

    def inStream

    def terminator
    def [streamShell, &unclaimedAvailable, triggerAvailable] := makeStreamShell(Element, thunk { impl.terminate(terminator) })

    bind terminator := streamShell.terminates()
    
    def waitersFlex := [].diverge()
    
    var implAvailable :Range := 0
    
    var remaining := ALL

    def setRemaining(new) {    
      remaining := new
      if (remaining <=> 0) {
        # Automatic close when reaching the known end
        inStream.close()
      }
    }
    
    /** update the visible 'available' - XXX should this be implicit? */
    def updateAvailable() {
      unclaimedAvailable :=  \
        if (waitersFlex.size() > 0 || Ref.isResolved(terminator)) \
          { 0 } else { implAvailable }
    }
    
    /** obtain without the scheduling. assumes arguments have been checked. */
    def obtainNow([atLeast, atMost, proceed, report], optEjector) {
      if (Ref.isBroken(terminator)) {
        # XXX make sub-problem accessible
        throw.eject(optEjector, 
                    if (Ref.optProblem(terminator) =~ p :notNull) \
                      {`$inStream failed: $p`} \
                      else {`$inStream closed`})
      }
      if (atLeast == ALL) {
        if (remaining != ALL) {
          # xxx would this work and simplify the semiObtain interface?
          # atLeast := remaining
        } else {
          throw.eject(optEjector, `<UnavailableException: not all remaining elements are available yet from $inStream>`) # XXX exception type, ejector
        }
      } else {
        if (atLeast > implAvailable) {
          throw.eject(optEjector, `<UnavailableException: $atLeast elements cannot be read at this time (only $implAvailable)>`) # XXX exception type, ejector
        }
      }

      def r := trace.runAsTurn(thunk {
        # xxx impl.tryAvailable(atMost)
        
        def taken := if (atMost == ALL) \
                       { implAvailable } \
                       else { atMost.min(implAvailable) }
        
        # Adjusting implAvailable: this must happen before semiObtain,
        # so that if semiObtain does setAvailable we don't overwrite
        # that value.
        switch (proceed) {
          match ==ADVANCE {
            if (implAvailable != ALL) {
              # xxx duplication: this is a small version of what 
              # backend.setAvailable must do
              implAvailable -= taken
              updateAvailable()
            }
            if (remaining != ALL) {
              setRemaining(remaining - taken)
            }
          }
          match ==QUERY {}
          match _ { throw("shouldn't have reached here with bad 'proceed' $proceed") }
        }

        def maybeElements := impl.semiObtain(taken, proceed, report)

        switch (report) {
          match ==ELEMENTS { maybeElements :List }
          match ==STATUS   { terminator }
          match _          { throw("shouldn't have reached here with bad 'report' $report") }
        }
        
        
      }, thunk {`semiObtain invocation by stream shell for $impl`})
      
      if (Ref.isBroken(r)) {
        if (!Ref.isResolved(terminator)) {
          streamShell.fail(Ref.optProblem(r))
        } else {
          traceln(`second failure for $inStream: ${Ref.optProblem(r)} ( first: ${terminator})`)
        }
        throw.eject(optEjector, Ref.optProblem(terminator))
      } else {
        return r
      }
    }
  
    /** resolve as many LATER data requests as we can */
    def triggerWaiters() {
      while (waitersFlex.size() > 0) {
        def [resolver, args] := waitersFlex[0]
        def [atLeast] + _ := args
        if (if (atLeast == ALL) { remaining != ALL || implAvailable == ALL } \
                           else { implAvailable >= atLeast } \ 
            || Ref.isResolved(terminator)) {
          # XXX use an ejector from obtainNow
          resolver.resolve(
            escape fail {
              try {
                obtainNow(args, fail) 
              } catch p { Ref.broken(p) }
            } catch p { Ref.broken(p) })
          waitersFlex(0, 1) := []
        } else {
          break
        }
      }
    }
    
    # Async is OK for termination notification
    Ref.whenResolved(terminator, def inStreamTerminationHandler(_) {
      triggerWaiters()
      triggerAvailable()
    })
    
    bind inStream extends streamShell { # implements InStream
      to __printOn(out :TextWriter) :void {
        out.write("<-")
        out.printSame(impl)
      }
      
      # XXX the nullOk should be Same[ANY]
      to obtain(atLeast :Range, atMost :(if (atLeast != ALL) {any[nullOk, (int >= atLeast)]} else {nullOk}), schedule :Schedule, proceed :Proceed, report :Report) {
        # XXX ejectors for UnavailableException and failure
        def args := [atLeast, atMost, proceed, report]
        return switch (schedule) {
          match ==NOW {
          
            if (waitersFlex.size() > 0) {
              if (atLeast != 0) {
                throw(`<UnavailableException: $atLeast elements cannot be read at this time ($implAvailable elements are claimed by ${waitersFlex.size()} LATER requests)>`)
              } else {
                return []
              }
            }
            
            obtainNow(args, null) # XXX ejector parameter
          }
          match ==LATER { 
            waitersFlex.push([def result, args])
            updateAvailable()
            triggerWaiters <- () # in case the request is immediately satisfiable
            result
          }
          match _ { throw(`shouldn't happen: unrecognized schedule $schedule`) }
        }
      }
      
      to remaining() { return remaining }
      
      to read(l, m)        { return inStream.obtain(l,   m,   NOW,   ADVANCE, ELEMENTS) }
      to readLater(l, m)   { return inStream.obtain(l,   m,   LATER, ADVANCE, ELEMENTS) }
      to readOptOne()  { return if (inStream.obtain(1,   1,   NOW,   ADVANCE, ELEMENTS) =~ [x]) {x}}
      to readAll()         { return inStream.obtain(ALL, ALL, NOW,   ADVANCE, ELEMENTS) }
      #to readAllLater()    { return inStream.obtain(ALL, ALL, LATER, ADVANCE, ELEMENTS) }
      to peek(l, m)        { return inStream.obtain(l,   m,   NOW,   QUERY,   ELEMENTS) }
      to skip(num)         { return inStream.obtain(num, num, LATER, ADVANCE, STATUS  ) }
      #to becomesReady(num) { return inStream.obtain(num, num, LATER, QUERY,   STATUS  ) }
    }
    
    bind backend {
      to setAvailable(new) { 
        require(remaining == ALL || new <= remaining, `available must not exeed remaining ($remaining, attempted to set to $new)`) 
        require(new == ALL || new >= implAvailable, `available must not decrease (was $implAvailable, attempted to set to $new)`)
        implAvailable := new
        triggerWaiters()
        updateAvailable()
        triggerAvailable()
      }
      
      to resolveRemaining(new :(int >= 0)) {
        require(if (implAvailable == ALL) { new == ALL} else { new >= implAvailable}, `remaining ($new) must not be less than available ($implAvailable)`)
        setRemaining(new)
        triggerWaiters()
        triggerAvailable()
      }
    }
    
    return inStream
  }
}



