# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("dot-props")

def Range := EIO::Range
def ALL := EIO::ALL

def makeStreamShell implements DeepFrozen {
  # XXX revise interface to have a single object for terminationHook and wants
  to run(Element, terminationHook, wants) {
  
    var available :Range := 0
    def [terminator, terminatorResolver] := Ref.promise()
    
    def noAvailableHandler {
      to requireNone() {}
      to run() { return true }
    }
    
    var availableHandler := noAvailableHandler
    def moreReactors := [].diverge()
  
    /** common operation of #terminate and #fail */
    def terminate(value ? (Ref.isBroken(value) || value == true)) {
      # close() after termination returns silently - XXX is this the Right Thing?
      if (!(Ref.isResolved(terminator) && value == true)) {
      
        terminatorResolver.resolve(value)
        available := 0
        terminationHook() # xxx consider whether this is the proper synchronous ordering
      }
      # XXX does failure correctly cause whenAvailable to be immediately called?
      return terminator
    }
  
    # NOTE: can't use org.cubik.cle.root because we have no 'self' reference
    def streamShell { # XXX implements Stream
      
      # XXX return interface's documentation
      
      # - availability -
      
      to available() { return available }
      
      to maxAvailable() {
        # XXX should be configurable by the impl
        return if (Ref.isResolved(terminator)) {0} else {ALL}
      }
      
      to whenAvailable(minimum, reactor) {
        availableHandler.requireNone()
        def result
        availableHandler := def activeAvailableHandler {
          to requireNone() {
            throw(`whenAvailable reactor ${E.toQuote(reactor)} already registered`)
          }
          to run() {
            if (available == ALL || available >= minimum || Ref.isResolved(terminator)) {
              availableHandler := noAvailableHandler
              # XXX more specific-case-informative exception 
              bind result := trace.runAsTurn(reactor, fn { `whenAvailable handler ${E.toQuote(reactor)} registered on stream shell` })
              return false
            } else {
              return true
            }
          }
        }
        
        if (availableHandler()  # handle immediate call if appropriate
                              ) {
          wants(minimum)
        }
        
        return result
      }
      
      /** 'reactor' is called with no arguments the next time 'available' increases, after the whenAvailable reactor. */
      to whenMoreAvailable(reactor) {
        moreReactors.push(reactor)
      }
      
      # - properties -
      
      to getElementType() { return Element }
      
      # - termination -
      
      to terminates() { return terminator }
      to isTerminated() { return Ref.isResolved(terminator) }
      
      to close() { return terminate(true) }
      to fail(problem) { return terminate(Ref.broken(problem)) }
      
    }
    
    def triggerAvailable() {
      availableHandler()
      for reactor in moreReactors.removeRun(0) { reactor() }
    }
    
    return [streamShell, &available, triggerAvailable]
  }
}



