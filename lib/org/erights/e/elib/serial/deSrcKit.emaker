#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

# copied 2007-08-17 from EoJ r466, modified for DeepFrozen

def makeURIKit :DeepFrozen := <import:org.quasiliteral.syntax.makeURIKit>
def DEBuilderOf :DeepFrozen := <elib:serial.DEBuilderOf>
def deENodeKit :DeepFrozen := <elib:serial.deENodeKit>
def makePrettyFeeder :DeepFrozen := <elang:syntax.makePrettyFeeder>
def makeELexer :DeepFrozen := <elang:syntax.makeELexer>
def makeEParser :DeepFrozen := <elang:syntax.makeEParser>

/**
 * Prints a Kernel-E AST with some syntactic shorthands restored.
 * <p>
 * This is currently used only for printing the output of uneval, so it
 * currently handles the AST cases generated by uneval, but few if any others.
 *
 * @author Mark S. Miller
 */
def deSrcKit implements DeepFrozen, ExitViaHere {

    to makeBuilder() :near {
        deSrcKit.makeBuilder(79, 1)
    }

    to makeBuilder(wrapColumn :int, sugarLevel :int) :near {

        # The index of the next temp variable
        var nextTemp := 0

        def deSrcBuilder implements DEBuilderOf(String, String) {

            to getNodeType() :near { String }
            to getRootType() :near { String }

            to buildRoot(root :String) :String {
                def result := makePrettyFeeder.pretty(root)
                # Remove terminal newline
                def last := result.size() -1
                if (last >= 0 && result[last] == '\n') {
                    result(0,last)
                } else {
                    result
                }
            }

            to buildLiteral(value) :String {
                if (value =~ i :int && i.bitLength() > 120 && false) {
                    # XXX disabled because E-on-CL doesn't have the String64 operators yet
                    def quot64 := i.toString64().quote()
                    return `__makeInt.fromString64($quot64)`
                } else {
                    return E.toQuote(value)
                }
            }

            to buildImport(varName :String) :String {
                if (varName =~ `@{protocol}__uriGetter`) {
                    return `<$protocol>`
                } else {
                    return varName
                }
            }
            to buildIbid(tempIndex :int) :String {
                return `t__$tempIndex`
            }

            to buildCall(var rec :String,
                         verb :String,
                         args :List[String]) :String {
                if (rec =~ `def t__@_`) {
                    # the result would otherwise misparse.
                    rec := `($rec)`
                }
                var argList := ", ".rjoin(args)
                if (rec.size() + argList.size() > wrapColumn - 20) {
                    argList := ",\n".rjoin(args)
                }
                if (args.size() >= 1 &&
                      rec.size() + args[0].size() > wrapColumn - 20) {

                    argList := "\n" + argList + "\n"
                }

                if (sugarLevel <= 0) {
                    return `$rec.$verb($argList)`
                }

                switch ([rec, verb, args]) {
                    match [`<@protocol>`, `get`, [`"@body"`]] ?
                      (makeURIKit.isURICs(body) && ! body.contains('\\')) {

                        return `<$protocol:$body>`
                    }
                    match [_, `get`, _] {
                        return `$rec[$argList]`
                    }
                    match [`__makeList`, `run`, _] {
                        return `[$argList]`
                    }
                    match [_, `run`, _] {
                        return `$rec($argList)`
                    }
                    match [_, `negate`, []] {
                        return `-$rec`
                    }
                    match _ {
                        if (makeELexer.isIdentifier(verb)) {
                            return `$rec.$verb($argList)`
                        } else {
                            return `$rec.${E.toQuote(verb)}($argList)`
                        }
                    }
                }
            }

            to buildDefine(rValue :String) :Tuple[String, int] {
                def tempIndex := nextTemp
                nextTemp += 1
                [`def t__$tempIndex := $rValue`, tempIndex]
            }

            to buildPromise() :int {
                def promIndex := nextTemp
                nextTemp += 2
                promIndex
            }

            to buildDefrec(resIndex :int, rValue :String) :String {
                def promIndex := resIndex -1
                `def t__$promIndex := $rValue`
            }
        }
    }

    to recognize(src :String, builder) :(builder.getRootType()) {
        # 'makeEParser' is a misnomer for the usage shown here. We're asking it
        # to parse, not to make a parser.
        var ast := makeEParser(src)
        # repair circular definition form
        deENodeKit.recognize(ast, builder)
    }
}
