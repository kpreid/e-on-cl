# Copyright 2005-2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")

pragma.enable("accumulator")
pragma.enable("function-implements")

/** Non-coercing guard wrapper. */
def Really {
  to get(guard) {
    return def reallyGuard {
      to coerce(specimen, optEjector) {
        def coerced := guard.coerce(specimen, optEjector)
        if (coerced != specimen) {
          throw.eject(optEjector, E.toQuote(coerced) + " must be same as original specimen " + E.toQuote(specimen))
        }
        return coerced
      }
    }
  }
}

/** Version of collection.maps(key) that has fewer dependencies. */
def _maps(collection, key) { collection.fetch(key, fn { return false }); return true }

def ConstList := <import:org.cubik.cle.prim.ConstList>

/** Version of safeScope["require"] that has fewer dependencies. */
def requireDF(condition, problemThunk) :void {
  if (!condition) { throw(problemThunk()) }
}

def makeCallExpr := <import:org.erights.e.elang.evm.makeCallExpr>

def [NounExpr, EExpr, ENode, FinalPattern, IfExpr, SeqExpr] := \
  { var types := []
    ["NounExpr", "EExpr", "ENode", "FinalPattern", "IfExpr", "SeqExpr"] \
      .iterate(fn _,name {types := types.with(<import>["org.erights.e.elang.evm.type." + name]); null})
    types
  }


def primParser := <import:org.cubik.cle.prim.parser>
/** Version of e__quasiParser that doesn't do proper substitution, so has fewer dependencies. */
def eDF__quasiParser {
  to valueMaker(text) {
    requireDF((text.indexOf1('$') == -1) & (text.indexOf1('@') == -1), fn{"eDF`` doesn't support holes or escapes"})
    def parsed := primParser(text)
    def substituter {
      to substitute(_) {
        return parsed
      }
    }
    return substituter
  }
}

def exprShorten(expr) {
  return \
    escape mismatch {
      def s :Really[SeqExpr] exit mismatch := expr
      def [single] exit mismatch := s.getSubs()
    } catch _ {
      expr
    }
}

def emptyStatic := <import:org.cubik.cle.prim.makeStaticScope>.getEmptyScope()

def DeepFrozenAuthor(DeepFrozenStamp) {

  def DeepFrozen0
  def OptionallyDeepFrozen
  def EventuallyDeepFrozen

  # lazily load the brand, because requireDeepFrozen must be initially loadable with no import dependencies, since it is used in <import>'s cache check '
  var getPeekBrandKit := null
  getPeekBrandKit := fn {
    def kit := <import:org.erights.e.elib.sealing.makeBrand>("EventuallyDeepFrozen state peeking")
    getPeekBrandKit := fn { kit }
    kit
  }
  
  def &peekSealer := def _{to getValue() { return getPeekBrandKit().getSealer() } }
  def &peekUnsealer := def _{ to getValue() { return getPeekBrandKit().getUnsealer() } }
  def &peekBrand := def _{ to getValue() { return getPeekBrandKit().getBrand() } }

  def rtrace(msgThunk) {
    #traceln(if (msgThunk =~ msg :String) {msg} else {msgThunk()})
  }

  # XXX sofar should be a set instead, but those aren't implemented yet
  def requireDeepFrozen(specimen, sofar, optEjector, root) :void {
    rtrace(fn{ "requireDeepFrozen " + E.toQuote(specimen) + ", " + E.toQuote(sofar.getKeys()) + ", " + E.toQuote(optEjector) + ", " + E.toQuote(root) })
    def specimenKey := __equalizer.makeTraversalKey(specimen)
    if (_maps(sofar, specimenKey)) {
      # recursion check
      return
    } else {
      def sofarther := sofar.with(specimenKey, null)
      
      if (__auditedBy(DeepFrozenStamp, specimen)) {
        # atomic DeepFrozenness
        rtrace("--rDF atomic")
        return

      } else if (__equalizer.isSelfless(specimen)) {
        # An object which is Selfless by definition has no mutable state (because that would give it an identity) that is not exposed as a 'separate' reference via its uncall.
        
        # we can't use :__Portrayal here because that's a cyclic dependency on E-implemented guards which want to be DeepFrozen-audited
        if ((def uncall := specimen.__optUncall()) != null) {
          def sub(_, component) {
            requireDeepFrozen(component, sofarther, optEjector, root)
          }
          
          sub(null, uncall[0])
          sub(null, uncall[1])
          ConstList.coerce(uncall[2], throw).iterate(sub)
          
          rtrace("--rDF selfless")
          return
        } else {
          throw("can't happen: PassByCopy object " + E.toQuote(specimen) + " returned null from __optUncall and is not stamped DeepFrozen")
        }
        
      } else if (__auditedBy(EventuallyDeepFrozen, specimen)) {
        rtrace("-rDF entering EventuallyDeepFrozen case")
        # translucent
        
        # XXX For efficiency, we should allow the object to carry a cached flag indicating that it has been proven deep-frozen.
        # We can tell it to set the flag if and only if this entire requireDeepFrozen operation completes; or, more precisely, once the specimen has been accepted and we have reached a point where sofar is empty. If sofar is not empty, it is possible that the specimen contains a reference to something whose DeepFrozenness is still being checked.
        
        
        # The auditor ensures that this will not fail.
        def state := peekUnsealer.unseal(specimen.__optSealedDispatch(peekBrand))
        
        escape ejectorForTranslucent {
          # using optEjector in the recursion would lead to revealing to our client some contents of the object being checked
          for component in state.getValues() {
            requireDeepFrozen(component, sofarther, ejectorForTranslucent, root)
          }
        } catch p {
          # XXX make the fallthrough else below eject a typed exception that we use in generating this message, so the client can know whether this is unsettled ('change your code to wait longer') or definitely not DeepFrozen ('sorry, hopeless')
          # xxx future extensions: make this exception contain (sealed) the full details of what chain of subobjects led to the non-DeepFrozen object.
          rtrace(fn{"--rDF exiting and discarding subexception for privacy: " + E.toQuote(p)})
          traceln("DeepFrozen not-yet-eventually: " + E.toQuote(p))
          throw.eject(optEjector, E.toQuote(root) + " is not DeepFrozen because " + E.toQuote(specimen) + " contains references that are unsettled or not DeepFrozen")
        }
        rtrace("--rDF amplified")
        return

      } else if (Ref.isBroken(specimen)) {
        rtrace("--rDF broken")
        requireDeepFrozen(Ref.optProblem(specimen), sofarther, optEjector, root)
        return
      
      } else {
        rtrace("--rDF opaque")
        throw.eject(optEjector, 
          if (__equalizer.sameYet(specimen, root)) {
            E.toQuote(root) + " is not DeepFrozen"
          } else {
            E.toQuote(root) + " is not DeepFrozen because " + E.toQuote(specimen) + " is not"
          }
        )
      }
    }
    throw("can't happen")
  }

  

  def requireAudit(audition, fail) :void implements DeepFrozenStamp {
    def objectExpr := audition.getObjectExpr()
    
    def patternSS := objectExpr.getPattern().staticScope()
    
    for name => _ in objectExpr.getScript().staticScope().namesUsed() &! patternSS.defNames() {
      if (_maps(patternSS.varNames(), name)) {
        throw.eject(fail, E.toQuote(name) + " in the definition of " + audition.getFQName() + " is a variable pattern and therefore not DeepFrozen")
      } else {
        def slot := audition.getSlot(name)
        
        requireDeepFrozen(slot, [].asMap(), fail, def _ {to __printOn(out :TextWriter) { 
          out.quote(name)
          out.print(" in the lexical scope of ")
          out.print(audition.getFQName()) 
        }})
      }
    }
  }

  OptionallyDeepFrozen__Resolver.resolve({
  /** Acts as the DeepFrozen auditor, but will not throw if the object is not acceptable. */
  def OptionallyDeepFrozen implements DeepFrozenStamp {
    to audit(audition :EAudition) {
      escape fail {
        requireAudit(audition, fail)
        audition.ask(DeepFrozenStamp)
      }
      return false
    }
  }})
  
  EventuallyDeepFrozen__Resolver.resolve({
  /** Allows objects to be verified as DeepFrozen without requiring either transparency or that their components be settled at audit time, by having them implement a method to ...XXX finish writing this documentation */
  def EventuallyDeepFrozen implements DeepFrozenStamp {
    to getPeekBrand() { return peekBrand }
    to getPeekSealer() { return peekSealer }
  
    to audit(audition) {
      # xxx I am well aware that this code is an awful mess. I do plan to do something about it.
    
      def objectExpr := audition.getObjectExpr()
      
      def label := "EventuallyDeepFrozen: " + audition.getFQName()
      
      /** Return true if 'expr' is proven to, when evaluated in the objectExpr's scope preceded by 'precedingExprs', result in the then value of 'slot'. */
      def expressionWillHaveValue(expr :Really[EExpr], 
                                  slot :any,
                                  precedingNodes # :Really[List[ENode]]
                                 ) :boolean {
        def nounExpr :NounExpr exit fn _{return false} := expr
        return (audition.getSlot(def noun := nounExpr.getName()) == slot) \
               & accum true for p in precedingNodes {
                   _ & !(_maps(p.staticScope().outNames(), noun)) }
      }

      def script := objectExpr.getScript()
      def precedingExprs := [objectExpr.getPattern()] + objectExpr.getAuditorExprs()
      
      # The matcher is irrelevant provided that our method exists
      if ((def methds := script.getOptMethods()) != null) {
        # both 'method' and 'methods' are E keywords

        requireDF(
          for via (fn m,e{((m.getVerb() == "__optSealedDispatch") \
                           & (m.getPatterns().size() == 1)
                          ).pick(fn{m},e)()}) \
              methd in methds {
            
            def optResultGuard := methd.getOptResultGuard()
            if (optResultGuard != null) {
              requireDF(expressionWillHaveValue(optResultGuard, &any, objectExpr.getAuditorExprs()), 
                fn{label + ": __optSealedDispatch result guard is not any"})
            }
            
            def [brandPattern :Really[FinalPattern]] \
              exit fn _{throw(label + ": __optSealedDispatch argument pattern is not simple")} \
              := methd.getPatterns()
            requireDF(brandPattern.getOptGuardExpr() == null, 
              fn{label + ": __optSealedDispatch argument pattern must not have a guard"})
            # XXX We haven't implemented node pattern matching yet. Once EventuallyDeepFrozen is working, test and implement pattern matching and reenable this.
            # requireDF(methd.getBody() =~ \
            #     eDF`if ($brandPattern == @{auditorExpr ? expressionWillHaveValue(auditorExpr, &EventuallyDeepFrozen, auditorExprs + [brandPattern] + if (optResultGuard) {[optResultGuard]} else {[]})}.getPeekBrand()) { meta.getState() }`, 
            #   fn{`$label: __optSealedDispatch body is not suitably formed`})
            def methodBody := exprShorten(methd.getBody())
            def ifExpr :Really[IfExpr] \
              exit fn _{throw(label + ": __optSealedDispatch body is not an if, but the " + E.toQuote(methodBody.__getAllegedType()) + " " + E.toQuote(methodBody))} \
              := methodBody
            
            # XXX overly restrictive - we should extract the EventuallyDeepFrozen noun and check it instead of requiring that particular name
            requireDF((exprShorten(ifExpr.getTest()) == makeCallExpr(null, eDF`__equalizer`, "sameEver", [brandPattern.getNoun(), eDF`EventuallyDeepFrozen.getPeekBrand()`], null)) \
                      & expressionWillHaveValue(eDF`EventuallyDeepFrozen`, &EventuallyDeepFrozen, precedingExprs + [brandPattern] + if (optResultGuard != null) {[optResultGuard]} else {[]}) \
                      & expressionWillHaveValue(eDF`__equalizer`, &__equalizer, precedingExprs + [brandPattern] + if (optResultGuard != null) {[optResultGuard]} else {[]}),
              fn{label + ": __optSealedDispatch if test does not compare the given brand to the peek brand"})
              
            # overly restrictive in the same way as the previous
            requireDF((exprShorten(ifExpr.getThen()) == eDF`EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())`) \
                      & expressionWillHaveValue(eDF`EventuallyDeepFrozen`, &EventuallyDeepFrozen, precedingExprs + [brandPattern] + if (optResultGuard != null) {[optResultGuard]} else {[]} + [ifExpr.getTest()]),
              fn{label + ": __optSealedDispatch if body is not EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())"})
            
            break true
          } != null, 
          fn{label + ": no __optSealedDispatch/1 method found"})
      } else {
        throw(label + ": auditing plumbing not yet supported")
      }
      
      return true
    }
  }})

  DeepFrozen0__Resolver.resolve(def DeepFrozen implements DeepFrozenStamp {
    to __printOn(out :TextWriter) :void {
      out.print("DeepFrozen")
    }
    
    to audit(audition :EAudition) :boolean {
      requireAudit(audition, throw)
      audition.ask(DeepFrozenStamp)
      return false
    }
    
    to isDeepFrozen(specimen) :boolean {
      escape notOk { 
        requireDeepFrozen(specimen, [].asMap(), notOk, specimen)
        return true
      }
      return false
    }
    
    to coerce(specimen, optEjector) :any {
      # XXX allow coercion?
      requireDeepFrozen(specimen, [].asMap(), optEjector, specimen)
      return specimen
    }
    
    /** Audits as DeepFrozen, but does not throw an exception if the object is unacceptable. */
    to optionally() {
      return OptionallyDeepFrozen
    }
    
    /** Returns the eventually-DeepFrozen author, which allows objects to be verified as DeepFrozen without requiring either transparency or that their components be settled at audit time. */
    to "eventually"() {
      return EventuallyDeepFrozen
    }
  })
  
  return DeepFrozen0
}
