# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")

def EventuallyDeepFrozen := DeepFrozen."eventually"()

def makeListShell

# XXX I expect to move this to a separate emaker.
def makeReadOnlyList implements EventuallyDeepFrozen {
  method __optSealedDispatch(brand) :any {
    if (brand == EventuallyDeepFrozen.getPeekBrand()) {
      EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
    }
  }

  to run(rwImpl) {
    def readOnlyListImpl {
      method get(i) { rwImpl[i] }
      method size() { rwImpl.size() }
      method snapshot() { rwImpl.snapshot() }
    }
    return def roList extends makeListShell(roList, readOnlyListImpl) {
      to __printOn(out :TextWriter) :void {
        out.printSame(rwImpl)
        out.write(".readOnly()")
      }
    }
  }
}

bind makeListShell implements EventuallyDeepFrozen {
  method __optSealedDispatch(brand) :any {
    if (brand == EventuallyDeepFrozen.getPeekBrand()) {
      EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
    }
  }

  to run(self, impl) {
    def list {
    
      method size() { impl.size() }
    
      to iterate(assocFunc) {
        var i := 0
        def size := impl.size()
        while (i < size) {
          assocFunc(i, impl[i])
          i += 1
        }
      }
      
      to run(start :int, endd :int) {
        # other way: impl.snapshot()(start, endd)
        return __makeList.fromIteratableValues(
          def _ { to iterate(assocFunc) {
            # could use the for-in-.. here but I want to keep options open
            var i := start
            while (i < endd) {
              assocFunc(null, impl[i])
              i += 1}}})
      }
      
      to snapshot() {
        return impl.snapshot()
      }
      to diverge(valueGuard) {
        return self.snapshot().diverge(valueGuard) # XXX unnecessarily inefficient
      }
      to diverge() {
        return self.diverge(any)
      }
      to readOnly() {
        return makeReadOnlyList(self)
      }
    
      to printOn(openS, sepS, closeS, out :TextWriter) {
        out.write(openS)
        var first := true
        for value in self {
          if (first) {
            first := false
          } else {
            out.write(sepS)
          }
          out.quote(value)
        }
        out.write(closeS)
      }
    }
    return list
  }
}