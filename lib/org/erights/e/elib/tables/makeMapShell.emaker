# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")

def makeFlexMap := <import:org.erights.e.elib.tables.makeFlexMap>

def EventuallyDeepFrozen := DeepFrozen."eventually"()

def makeMapShell

# XXX I expect to move this to a separate emaker.
def makeReadOnlyMap implements EventuallyDeepFrozen {
  method __optSealedDispatch(brand) :any {
    if (brand == EventuallyDeepFrozen.getPeekBrand()) {
      EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
    }
  }

  to run(rwImpl) {
    return def roMap := makeMapShell(roMap, def readOnlyMapImpl {
      to __printOn(out :TextWriter) :void {
        out.printSame(rwImpl)
        out.write(".readOnly()")
      }
      method fetch(k, t) { rwImpl.fetch(k, t) }
      method getPair() { rwImpl.getPair() }
      method getKeys() { rwImpl.getKeys() }
      method getValues() { rwImpl.getValues() }
      method snapshot() { rwImpl.snapshot() }
    })
  }
}

/** Implements the full Map interface given an object implementing the data storage. */
bind makeMapShell implements EventuallyDeepFrozen {
  method __optSealedDispatch(brand) :any {
    if (brand == EventuallyDeepFrozen.getPeekBrand()) {
      EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
    }
  }

  to run(self, impl) {
    # XXX should not delegate to the impl
    def map := def "org.erights.e.elib.tables.Map" extends impl { # implements Map
      
      # XXX implement returning Map interface documentation in our alleged type?
      
      to __printOn(out :TextWriter) :void {
        # Simplifying the client's job: delegate printOn behavior to the implementation so we don't need to be wrapped in nearly every case.
        out.printSame(impl)
      }

      method get(key) { impl.fetch(key, thunk{ throw(E.toQuote(key) + " not found") }) }
      to maps(key) :boolean { impl.fetch(key, thunk{ return false }); return true }
      
      to iterate(assocFunc) {
        # XXX should probably have primitive iterate
        for key in impl.getKeys() {
          assocFunc(key, self[key])
        }
      }
      
      to diverge(keyGuard, valueGuard) {
        def fm := makeFlexMap.fromTypes(keyGuard, valueGuard)
        escape duplicate {
          fm.putAll(self, true, duplicate)
        } catch dupException {
          # XXX dupException should tell us what key it was, but doesn't yet
          # XXX quote, not print
          throw(`duplicate keys in $self under $keyGuard coercion`) # ` while attempting to make a FlexMap`
        }
        return fm
      }
      method diverge() { self.diverge(any, any) }
      method snapshot() {
        def [keys, values] := impl.getPair()
        __makeMap.fromColumns(keys, values)
      }
      to readOnly() {
        return makeReadOnlyMap(impl)
      }
      
      to printOn(openS, mapS, sepS, closeS, out :TextWriter) {
        out.write(openS)
        var first := true
        for key => value in self {
          if (first) {
            first := false
          } else {
            out.write(sepS)
          }
          out.quote(key)
          out.write(mapS)
          out.quote(value)
        }
        out.write(closeS)
      }
    }
    return map
  }
}

# XXX this file is in need of tests - it is currently only tested indirectly by its use in the standard flex-map

