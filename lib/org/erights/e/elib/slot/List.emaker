# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("accumulator")

def simplifyFQName := <import:org.cubik.cle.prim.simplifyFQName>
def makeCoercionFailure := <import:org.cubik.cle.fail.makeCoercionFailure>
def EventuallyDeepFrozen := DeepFrozen."eventually"()

def List0 implements EventuallyDeepFrozen {

  method __optSealedDispatch(brand) :any {
    if (brand == EventuallyDeepFrozen.getPeekBrand()) {
      EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
    }
  }

  to __printOn(out :TextWriter) {
    out.print("List")
  }

  to coerce(specimen, optEjector) {
    if (specimen =~ [] + list) {
      return list
    } else {
      throw.eject(optEjector, makeCoercionFailure(specimen, List))
    }
  }

  to get(elementGuard) {
    def List1 implements EventuallyDeepFrozen {

      method __optSealedDispatch(brand) :any {
        if (brand == EventuallyDeepFrozen.getPeekBrand()) {
          EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
        }
      }

      to coerce(var specimen, optEjector) {
        specimen := List0.coerce(specimen, optEjector)
        
        # XXX we need a more efficient way of doing this which doesn't require accumulating a new list for non-coercing cases
        return accum [] for subSpecimen in specimen {
          _.with(elementGuard.coerce(subSpecimen, optEjector))
        }
      }
    
      to __printOn(out :TextWriter) {
        out.print("List[")
        out.quote(elementGuard)
        out.print("]")
      }
    }
    
    return List1
  }
  
  to getTheTrivialValue() { return [] }
}