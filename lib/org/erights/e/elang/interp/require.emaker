# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

# E-on-CL note: This file has been modified to not depend on elib__uriGetter, to avoid the cyclic dependency:
#   <elib>
#   => <import:org.erights.e.elang.interp.makePackageLoader>
#   => DeepFrozen check by <import>
#   => DeepFrozenAuthor.emaker
#   => for-loop expansion using require()
#   => this file
#   => <elib>
#
# XXX better would be to not use prim.E.require at all.

def EE := <import:org.erights.e.elib.prim.E>

/**
 * Used to ensure a condition is true before proceeding. If the
 * condition isn't true, the complaint is thrown
 */
def require0 { # implements DeepFrozen
    to (cond) :void {
        EE.require(cond)
    }
    to (cond, problem) :void {
        EE.require(cond, problem)
    }
    match [`run`, [cond, prob0] + probRest] {
        if (! cond) {
            var problem := prob0
            for prob in probRest {
                problem := problem + prob
            }
            EE.require(false, problem)
        }
    }
}

    ? require(2 == 3, thunk{"foo"})
    # problem: foo
    #
    #   <elang:interp.Thrower>("foo")
    #   <require0>(false, <e object>)
    #   <interp> evalPrint(e`require run(Ref same(2, 3), \
    #   /**  * Needs a docComment  */ def _ {     \
    #   to run :any {         "foo"     } })`)

    ? require(2 == 2, thunk{"foo"})
    ? require(2 == 3)
    # problem: required condition failed
    #
    #   <elang:interp.Thrower>("required condition failed")
    #   <require0>(false, <e object>)
    #   <require0>(false)
    #   <interp> evalPrint(e`require run(Ref same(2, 3))`)

    ? require(2 == 2)
    ? require(2 == 3, "foobar")
    # problem: foobar
    #
    #   <elib:prim.E> require(false, "foobar")
    #   <require0>(false, "foobar")
    #   <interactive interp> evalPrint(e`require run(__equalizer isSame(2, 3),\
    #   "foobar")`)

