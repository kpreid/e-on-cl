# Copyright 2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")

def utf_8 := <import:org.cubik.cle.charsets>["UTF-8"]

def UnsignedInteger := <import:org.cubik.cle.binary.UnsignedInteger>

def Short := UnsignedInteger[16]

def UTF8StringWithLength16 extends String implements DeepFrozen, ExitViaHere { # implements Binary
  to writingTo(out) { # , schedule
    # XXX verify stream's byte size
    def writeShort := Short.writingTo(out)
    return def writer(value :UTF8StringWithLength16) {
      def data := EIO.takeAll(utf_8.encode(value.asStream(), [].asMap()))
      writeShort(data.size()) # may fail
      out.reserve().resolve(data)
    }
  }
  to takingFrom(ins) { # , schedule
    # XXX verify stream's byte size
    def readShort := Short.takingFrom(ins)
    return def taker() :UTF8StringWithLength16 {
      def size := readShort()
      # XXX unnecessarily non-streaming; fixable with a "substream of N of the characters from this stream"
      def data := EIO.takeRange(size, size, ins)
      def ta := EIO.takeAll(utf_8.decode(data.asStream(), [].asMap()))
      # workaround for bug in takeRange
      return if (ta == []) { "" } else { ta }
    }
  }
}