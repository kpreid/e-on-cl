# Copyright 2007-2008 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")

def utf_8 := <import:org.cubik.cle.charsets>["UTF-8"]

def UnsignedInteger := <import:org.cubik.cle.binary.UnsignedInteger>

def Short := UnsignedInteger[16]

def UTF8StringWithLength16 extends String implements DeepFrozen, ExitViaHere { # implements Binary
  to writingTo(out) { # , schedule
    # XXX verify stream's byte size
    def writeShort := Short.writingTo(out)
    return def writer(value :UTF8StringWithLength16) {
      def data := EIO.takeAll(utf_8.encode(value.asStream(), [].asMap()))
      writeShort(data.size()) # may fail
      out.reserve().resolve(data)
    }
  }
  to takingFrom(ins, schedule) {
    # XXX verify stream's byte size
    def readShort := Short.takingFrom(ins, schedule)
    return def taker() :(schedule.result(UTF8StringWithLength16)) {
      return schedule.whenResolved(readShort(), fn size {
        # XXX unnecessarily non-streaming; fixable with a "substream of N of the characters from this stream"
        schedule.whenResolved(EIO.takeRange(size, size, ins), fn data {
          def ta := EIO.takeAll(utf_8.decode(data.asStream(), [].asMap()))
          # workaround for bug in takeRange
          if (ta == []) { "" } else { ta }
        })
      })
    }
  }
}