# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("dot-props")

def makeInStreamShell := <elib:eio.makeInStreamShell>
def ALL := EIO::ALL

# XXX expose
interface BufferedInStreamImpl {
  to wants(n :(int > 0)) :void
  to taken(n :(int >= 0)) :void
  to terminate(terminator) :void
}

interface BufferedInStreamBackend {
  to buffered() :(int >= 0)
  to close() :void
  to supply(elements :List) :void
}

# XXX write tests for this

def makeBufferedInStreamShell implements DeepFrozen {
  to run(Element, backend__Resolver, impl) {

    def buffer := [].diverge(Element)

    def stream := makeInStreamShell(Element, def issBackend, def bufferImpl {
      to __printOn(tw :TextWriter) {
        tw.printSame(impl)
      }
      
      to semiObtain(count :(EIO::Range), proceed, report) {
        def n := if (count == ALL) { buffer.size() } else { buffer.size().min(count) }
        return if (proceed == EIO::ADVANCE) {
          try { # I want PROG1
            buffer.removeRun(0, n)
          } finally {
            impl.taken(n)
          }
        } else if (report == EIO::ELEMENTS) {
          buffer.run(0, n)
        }
      }
      
      to wants(n) { if (impl.__respondsTo("wants", 1)) { impl.wants(n) } }
      
      to terminate(t) { impl.terminate(t) }
    })

    var closed := false

    bind backend {
      to buffered() :int { return buffer.size() }
      to close() :void { 
        closed := true
        issBackend.resolveRemaining(buffer.size()) }
      to supply(elements) :void {
        if (closed) {
          throw(`cannot supply more elements for $stream because it has been backend-closed`)
        } else {
          buffer.append(elements)
          issBackend.setAvailable(buffer.size())
        }
      }
    }

    return stream
  }
}
