# Copyright 2005-2007 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.syntax("0.9")
pragma.enable("dot-props")
pragma.enable("accumulator")

def makeBufferedInStreamShell := <import:org.cubik.cle.io.makeBufferedInStreamShell>

def Range := EIO::Range
def ALL := EIO::ALL

def Element := int # XXX should be int8 (0..255)

def makeFDInStreamAuthor implements ExitViaHere {
  to run(lisp) {
    # XXX reduce the amount of lisp stuff this emaker uses

    def DeepFrozenStamp := lisp["E.ELIB", "+DEEP-FROZEN-STAMP+"]::value
    def read := lisp["CL", "READ-FROM-STRING"]::"function"
    def intern := lisp["CL", "INTERN"]::"function"
    def l__quasiParser {
      to valueMaker(t :String) {
        return def vm {
          to substitute(values) { return read(simple__quasiParser.valueMaker(t).substitute(values)) }
        } 
      }
    }

    def fooAddReceiveHandler := lisp["E.STREAMS", "FOO-ADD-RECEIVE-HANDLER"]::"function"
    def fooRemoveReceiveHandler := lisp["E.STREAMS", "FOO-REMOVE-RECEIVE-HANDLER"]::"function"

    /** Make an InStream that reads from a non-blocking-POSIX-read()-style data source. */
    def makeFDInStream implements DeepFrozenStamp {
      /** 'nameObj' is used for printing the stream. */
      to run(nameObj :any, fdRef, bufferLimit :(int >= 1)) {

        def inFDHandler
        def removeHandler() {
          fooRemoveReceiveHandler((lisp["ELIB", "REF-SHORTEN"]::"function")(inFDHandler))
        }
        
        def inStream := makeBufferedInStreamShell(Element, def inBackend, def inImpl {
          to __printOn(out :TextWriter) {
            out.printSame(nameObj)
          }

          # XXX todo: try a lazily-reading version - reads more only upon wants()
          to taken(_) {}
          
          to terminate(t) { 
            # XXX proper error handling?
            removeHandler()
            escape ignore {
              fdRef.shutdown(l`:input`, def shutdownError(error) {
                trace(`error from shutdown for $inStream: $error`)
                ignore()
              })
            }
          }
          
        })
        
        def vat := lisp["E.ELIB", "*VAT*"]::value
        
        bind inFDHandler := fooAddReceiveHandler(fdRef, def fdHandler() {
          
          escape error {
            escape eofExit {
              def elements := fdRef.read(bufferLimit - inBackend.buffered(), error, eofExit)
              #trace(`$inStream: read $elements from fd $fdRef`)
              inBackend <- supply(elements)
            } catch _ {
              trace(`$inStream: eof from $fdRef`)
              removeHandler()
              inBackend <- close()
            }
          } catch p {
            trace(`$inStream: error $p from $fdRef`)
            removeHandler()
            # XXX this effectively discards any input that's been buffered
            inStream.fail(p)
          }
        })
        
        return inStream
      }
    }
    return makeFDInStream
  }
}
