# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("dot-props")
pragma.enable("verb-curry")
pragma.enable("accumulator")

def makeInStreamShell := <elib:eio.makeInStreamShell>

def Range := EIO::Range
def ALL := EIO::ALL

def Element := int # XXX should be int8 (0..255)

def makeFDInStreamAuthor {
  to run(lisp) {

    def DeepFrozenStamp := lisp["E.ELIB", "+DEEP-FROZEN-STAMP+"]::value
    def read := lisp["CL", "READ-FROM-STRING"]::"function"
    def l__quasiParser {
      to valueMaker(t) {
        return def vm {
          to substitute(values) { return read(simple__quasiParser.valueMaker(t).substitute(values)) }
        } 
      }
    }
    def lispFunction := lisp["E.KNOT", "E-TO-LISP-FUNCTION"]::"function"
    def withTurn := lisp["E.ELIB", "%WITH-TURN"]::"function"

    def makeFDInStream implements DeepFrozenStamp {
      to run(nameObj, inBuffer, bufferLimit, fdRef) {
        def inStream := makeInStreamShell(Element, def inBackend, def inImpl {
          to __printOn(out :TextWriter) {
            out.printSame(nameObj)
          }
          
          to semiObtain(atLeast :int, atMost :Range, proceed, report) {
            # XXX use constants from InStream-somehow
            def n := if (atMost == ALL) { inBuffer.size() } else { inBuffer.size().min(atMost) }
            return if (proceed == "ADVANCE") {
              inBuffer.removeRun(0, n)
            } else if (report == "ELEMENTS") {
              inBuffer.run(0, n)
            }
          }
          
        })
    
        var eof := false
    
        def inFDHandler
        def removeHandler() {
          (lisp["SB-SYS", "REMOVE-FD-HANDLER"]::"function")((lisp["ELIB", "REF-SHORTEN"]::"function")(inFDHandler))
        }
        
        def vat := lisp["E.ELIB", "*VAT*"]::value
        
        bind inFDHandler := (lisp["SB-SYS", "ADD-FD-HANDLER"]::"function")(fdRef.getFD(), l`:input`, lispFunction(def fdHandlerFunc(_) {
          
          withTurn(lispFunction(thunk {
          
            escape error {
              escape eofExit {
                def elements := fdRef.read(bufferLimit - inBuffer.size(), error, eofExit)
                #traceln(`$inStream: read $elements from fd $fdRef`)
                inBuffer.append(elements)
              } catch _ {
                traceln(`$inStream: eof`)
                removeHandler()
                eof := true
              }
            } catch p {
              traceln(`$inStream: error $p`)
              removeHandler()
              inStream.fail(p)
            }
            
            inBackend.setAvailable(inBuffer.size())
            
          }), vat)
          
        }))
        
        return inStream
      }
    }
    return makeFDInStream
  }
}