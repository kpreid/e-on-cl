# Copyright 2005-2006 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("accumulator")

#def &term__quasiParser0 := <elib:slot.makeLazySlot>(thunk {
#  makeQBuilder(null)
#})

def makeTermParser := <import:org.quasiliteral.term.makeTermParser>
def makeAstroTag := <import:org.quasiliteral.astro.makeAstroTag>
def AstroTag := makeAstroTag.asType()
def makeBaseAstroBuilder := <import:org.quasiliteral.astro.makeBaseAstroBuilder>

interface QAstroArg guards QAstroArgStamp {}
def QFunctor := QAstroArg # XXX restrict
def QTerm := QAstroArg # XXX restrict
def SourceSpan := <elib:base.makeSourceSpan>.asType()

def memoize := <import:org.cubik.cle.memoize>
def EventuallyDeepFrozen := DeepFrozen."eventually"()

def qtPrint implements DeepFrozen { to run(tw :TextWriter, what :QAstroArg) {
  tw.write("qterm`")
  what.termPrint(tw)
  tw.write("`")
}}

def _make implements DeepFrozen { to run(astroBuilder) {

  def qBuilder

  /** XXX faked for now */
  def schema implements DeepFrozen {
    to obtainTagForName(name) { return makeAstroTag(null, name, nullOk) }
  }
  
  def baseBuilder := makeBaseAstroBuilder(qBuilder, 
                                          schema,
                                          ["BAstroArg" => QAstroArg,
                                           ])

  bind qBuilder := def "$qBuilder" extends baseBuilder implements EventuallyDeepFrozen { # implements AstroBuilder?, QuasiBuilder?
    method __optSealedDispatch(brand) :any {
      if (brand == EventuallyDeepFrozen.getPeekBrand()) {
        EventuallyDeepFrozen.getPeekSealer().seal(meta.getState())
      }
    }
    
  
    to doesQuasis() { return true }
  
    to start(top :QTerm) { return top }
    
    to empty() {
      return def quasiEmpty implements QAstroArgStamp {
        to termPrint(tw :TextWriter) {
          # nothing
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiEmpty)
        }
      }
    }
    
    to term(functor :QFunctor) { return functor }

    to term(functor :QFunctor, args :QAstroArg) { 
      return def quasiTerm implements QAstroArgStamp {
        to substitute(sargs) {
          # XXX incomplete
          return astroBuilder.term(functor.substitute(sargs), args.substitute(sargs))
        }
      
        to termPrint(tw :TextWriter) {
          # XXX incapable of cycle handling
          functor.termPrint(tw)
          tw.print("(")
          args.termPrint(tw)
          tw.print(")")
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiTerm)
        }
      }
    }
    
    to valueHole(key :int) {
      return def quasiValueFunctorHole implements QAstroArgStamp { # XXX should be implements QFunctor?
        to substitute(args :List) {
          def holeValue := args[key]
          return switch (holeValue) {
            # XXX review this for correctness
            match data :any[int, float64, char] { 
              astroBuilder.leafData(data, null) }
            match name :String {
              # XXX ask astroBuilder to make us a tag-with-given-name instead
              astroBuilder.leafTag(makeAstroTag(null, name, nullOk), null) }
            match x { x }
          }
        }
      
        to termPrint(tw :TextWriter) {
          tw.write("${")
          tw.print(key)
          tw.write("}")
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiValueFunctorHole)
        }
      }
    }
    
    to leafData(data, optSpan :nullOk[SourceSpan]) {
      # XXX is this adequate?
      return def quasiData implements QAstroArgStamp { # implemens QFunctor
        to substitute(args) {
          return astroBuilder.leafData(data, optSpan)
        }
        
        to termPrint(out :TextWriter) {
          out.quote(data)
        }

        to __printOn(out) {
          qtPrint(out, quasiData)
        }
      }
    }
    
    to leafTag(tag :AstroTag, optSpan :nullOk[SourceSpan]) {
      def quasiFunctor implements QAstroArgStamp {
        to substitute(args) {
          # XXX for proper implementation see QFunctor.java
          return astroBuilder.leafTag(tag, null)
        }
      
        to termPrint(tw :TextWriter) {
          # XXX incorrect?
          tw.print(tag.getTagName())
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiFunctor)
        }
      }
      return quasiFunctor
    }
    
    /** XXX this doesn't exist in the Java version and I forget whether it's temporary or not */
    to tag(tagPieces :List[Tuple[String, String]]) {
      def tagName := accum "" for [kind, text] in tagPieces { _ + text}
      return qBuilder.leafTag(makeAstroTag(null, tagName, nullOk), null)
    }
    
     to seq(single :QTerm) {
      return single
    }
    
    match [=="seq", args :List[QTerm]] {
      def qBuilderSeq implements QAstroArgStamp {
        to getTerms() { return args }
        
        to substitute(sargs) {
          return E.call(astroBuilder, "seq",  accum [] for arg in args { _.with(arg.substitute(sargs)) })
        }
        
        to __printOn(out :TextWriter) {
          out.write("qtermSeq`(")
          var sep := ""
          for arg in args { 
            out.write(sep)
            out.print(arg)
            sep := ", "
          }
          out.write(")`")
        }
      }
    }

  }
  
  
  return qBuilder
}}

def makeQBuilder implements DeepFrozen {
  to getTerm__quasiParser() {
    def qBuilder := _make(<import:org.quasiliteral.term.makeTermBuilder>())
    def qparse := memoize({
      def "$qparse" implements DeepFrozen { to run(template :String) {
        return makeTermParser(qBuilder).parseText(template.asStream())
      }}
    })
    
    return def "$term__quasiParser" implements DeepFrozen {
      to valueMaker(template :String) {
        return qparse(template)
      }
  
      to matchMaker(template :String) {
        return qparse(template)
      }
    }
  }
  
  to run(abuilder) {
    return _make(abuilder)
  }
}