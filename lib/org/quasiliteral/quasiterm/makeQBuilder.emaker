# Copyright 2005 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

pragma.enable("easy-return")
pragma.disable("explicit-result-guard")
pragma.enable("accumulator")

#def &term__quasiParser0 := <elib:slot.makeLazySlot>(thunk {
#  makeQBuilder(null)
#})

def makeTermParser := <import:org.quasiliteral.term.makeTermParser>
def makeAstroTag := <import:org.quasiliteral.astro.makeAstroTag>
def AstroTag := makeAstroTag.asType()

interface QAstroArg guards QAstroArgStamp {}
def QFunctor := QAstroArg # XXX restrict
def QTerm := QAstroArg # XXX restrict
def SourceSpan := any # XXX restrict

def qtPrint implements DeepFrozen { to run(tw :TextWriter, what :QAstroArg) {
  tw.write("qterm`")
  what.termPrint(tw)
  tw.write("`")
}}

def _make implements DeepFrozen { to run(astroBuilder) {

  def qBuilder

  /** XXX faked for now */
  def schema {
    to obtainTagForName(name) { return makeAstroTag(null, name, nullOk) }
  }

  def maybeBaseBuilder := { def self := qBuilder; 
  /** BaseBuilder from E-on-Java - waiting on figuring out whether it's useful to us too to be split into its own emaker */
  def maybeBaseBuilder {
    to bag(args :QAstroArg) { # XXX proper guard?
      return self.term(self.leafTag(schema.obtainTagForName(".bag."), null), args)
    }
    to tuple(args :QAstroArg) { # XXX proper guard?
      return self.term(self.leafTag(schema.obtainTagForName(".tuple."), null), args)
    }
  }}

  bind qBuilder := def "$qBuilder" extends maybeBaseBuilder { # implements AstroBuilder?, QuasiBuilder?
  
    to doesQuasis() { return true }
  
    to start(top :QTerm) { return top }
    
    to empty() {
      return def quasiEmpty implements QAstroArgStamp {
        to termPrint(tw :TextWriter) {
          # nothing
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiEmpty)
        }
      }
    }
    
    to term(functor :QFunctor) { return functor }

    to term(functor :QFunctor, args :QAstroArg) { 
      return def quasiTerm implements QAstroArgStamp {
        to substitute(sargs) {
          # XXX incomplete
          return astroBuilder.term(functor.substitute(sargs), args.substitute(sargs))
        }
      
        to termPrint(tw :TextWriter) {
          # XXX incapable of cycle handling
          functor.termPrint(tw)
          tw.print("(")
          args.termPrint(tw)
          tw.print(")")
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiTerm)
        }
      }
    }
    
    to leafData(data, optSpan :nullOk[SourceSpan]) {
      # XXX is this adequate?
      return def quasiData implements QAstroArgStamp { # implemens QFunctor
        to substitute(args) {
          return astroBuilder.leafData(data, optSpan)
        }
        
        to termPrint(out :TextWriter) {
          out.quote(data)
        }

        to __printOn(out) {
          qtPrint(out, quasiData)
        }
      }
    }
    
    to leafTag(tag :AstroTag, optSpan :nullOk[SourceSpan]) {
      def quasiFunctor implements QAstroArgStamp {
        to substitute(args) {
          # XXX for proper implementation see QFunctor.java
          return astroBuilder.leafTag(tag, null)
        }
      
        to termPrint(tw :TextWriter) {
          # XXX incorrect?
          tw.print(tag.getTagName())
        }
        
        to __printOn(tw) {
          qtPrint(tw, quasiFunctor)
        }
      }
      return quasiFunctor
    }
    
    /** XXX this doesn't exist in the Java version and I forget whether it's temporary or not */
    to tag(tagPieces :List[Tuple[String, String]]) {
      def tagName := accum "" for [kind, text] in tagPieces { _ + text}
      return qBuilder.leafTag(makeAstroTag(null, tagName, nullOk), null)
    }
  
    to valueMaker(template :String) {
      # XXX cache
      return makeTermParser(qBuilder).parseText(template.asStream())
    }
  }
  return qBuilder
}}

def makeQBuilder implements DeepFrozen {
  to getTerm__quasiParser() {
    return _make(<import:org.quasiliteral.term.makeTermBuilder>())
  }
  
  to run(abuilder) {
    return _make(abuilder)
  }
}